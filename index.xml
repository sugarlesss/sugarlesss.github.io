<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>無糖的小宇宙</title>
        <link>https://sugarless.top/</link>
        <description>無糖的博客，一个知识网络沉淀，日常生活观察者的小宇宙。</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>jaded@foxmail.com (無糖)</managingEditor>
            <webMaster>jaded@foxmail.com (無糖)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 15 Sep 2021 00:00:00 &#43;0000</lastBuildDate>
            <atom:link href="https://sugarless.top/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>[ 置顶 ] 🚩 Github 项目 / 工具站点 / 有趣的站点</title>
    <link>https://sugarless.top/posts/mark/1.html</link>
    <pubDate>Tue, 31 Dec 2019 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/mark/1.html</guid>
    <description><![CDATA[<p>内容不定期持续更新，感谢每一位开源项目作者为全世界开发者做出的杰出贡献。本文主要分享一些我平时收集到的一些好物，东西可能比较杂乱。涵盖开源项目、免费的工具站、好用的客户端工具、优秀的付费网站和来路不明的沙雕网站。</p>
<h1 id="github-开源项目">Github 开源项目</h1>
<h2 id="功能性网站">功能性网站</h2>
<h3 id="1兰空图床">1、兰空图床</h3>
<p>使用 thinkphp + mysql 开发，界面简洁易用，支持第三方云储存和远程 FTP 存储。并且有开源的浏览器插件支持。（真香）</p>
<p>官网：<a href="https://www.lsky.pro" target="_blank" rel="noopener noreffer">https://www.lsky.pro</a></p>
<p>GitHub：<a href="https://github.com/wisp-x/lsky-pro" target="_blank" rel="noopener noreffer">https://github.com/wisp-x/lsky-pro</a></p>
<p>浏览器扩展：<a href="https://github.com/wisp-x/lsky-pro-chrome-extension" target="_blank" rel="noopener noreffer">https://github.com/wisp-x/lsky-pro-chrome-extension</a></p>
<h3 id="2基于-phphtml-的轻量级网络测试站点">2、基于 php+html 的轻量级网络测试站点</h3>
<p>HTML5 Speedtest 可用于查看下载速度、ping 速度、上传速度；很小巧方便，直接打开页面点击一下 start 就能自动检测，你本机到远程服务器的网络状况，快速得到观测数据</p>
<p>Github：<a href="https://github.com/librespeed/speedtest" target="_blank" rel="noopener noreffer">https://github.com/librespeed/speedtest</a></p>
<h3 id="3flarum-论坛">3、flarum 论坛</h3>
<p>基于 PHP Laravel 框架构建的一款优雅简洁论坛软件。发帖及跟帖回复使用 markdown 语法是一个亮点。</p>
<p>官网：<a href="https://flarum.org" target="_blank" rel="noopener noreffer">https://flarum.org</a></p>
<p>中文官网：<a href="https://flarum.org.cn" target="_blank" rel="noopener noreffer">https://flarum.org.cn</a></p>
<p>Github：<a href="https://github.com/flarum/flarum" target="_blank" rel="noopener noreffer">https://github.com/flarum/flarum</a></p>
<h2 id="命令行工具">命令行工具</h2>
<h3 id="1annie">1、annie</h3>
<p>基于 Go 开发的一款命令行视频下载器，支持的平台很多，包括 MacOS、Windows、Linux 等。目前支持 bilibili 和 youtube 的播放列表批量下载，其他网站只支持单个视频下载。</p>
<p>Github：<a href="https://github.com/iawia002/annie" target="_blank" rel="noopener noreffer">https://github.com/iawia002/annie</a></p>
<h3 id="2youtube-dl">2、youtube-dl</h3>
<p>下载 youtube 视频的神器
Github：<a href="https://github.com/ytdl-org/youtube-dl" target="_blank" rel="noopener noreffer">https://github.com/ytdl-org/youtube-dl</a>
官网：<a href="http://ytdl-org.github.io/youtube-dl/" target="_blank" rel="noopener noreffer">http://ytdl-org.github.io/youtube-dl/</a></p>
<h2 id="开发工具">开发工具</h2>
<h3 id="1anotherredisdesktopmanager">1、AnotherRedisDesktopManager</h3>
<p>一个 GUI Redis 桌面管理器，兼容 Linux、Windows、Mac。更重要的是，在加载大量的键时，它不会崩溃。</p>
<p>Github：<a href="https://github.com/qishibo/AnotherRedisDesktopManager" target="_blank" rel="noopener noreffer">https://github.com/qishibo/AnotherRedisDesktopManager</a></p>
<h3 id="2switchhosts">2、SwitchHosts</h3>
<p>SwitchHosts 是一个管理、切换多个 hosts 方案的工具。</p>
<p>Github：<a href="https://github.com/oldj/SwitchHosts" target="_blank" rel="noopener noreffer">https://github.com/oldj/SwitchHosts</a></p>
<p>官网：<a href="https://swh.app/zh/" target="_blank" rel="noopener noreffer">https://swh.app/zh/</a></p>
<h3 id="3docsify">3、docsify</h3>
<p>docsify 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 index.html 就可以开始编写文档并直接部署在 GitHub Pages。</p>
<p>Github：<a href="https://github.com/docsifyjs/docsify/" target="_blank" rel="noopener noreffer">https://github.com/docsifyjs/docsify/</a></p>
<p>官网：<a href="https://docsify.js.org/" target="_blank" rel="noopener noreffer">https://docsify.js.org/</a></p>
<h2 id="ui-框架">UI 框架</h2>
<h3 id="1layui">1、LayUI</h3>
<p>对非专业前端的开发人员非常友好，组件丰富，极低门槛，开箱即用。</p>
<p>官网：<a href="https://www.layui.com" target="_blank" rel="noopener noreffer">https://www.layui.com</a></p>
<p>GitHub：<a href="https://github.com/sentsin/layui" target="_blank" rel="noopener noreffer">https://github.com/sentsin/layui</a></p>
<h3 id="2vant-weapp">2、vant-weapp</h3>
<p>有赞出品的开源小程序 UI 组件库</p>
<p>官网：<a href="https://youzan.github.io/vant-weapp" target="_blank" rel="noopener noreffer">https://youzan.github.io/vant-weapp</a></p>
<p>GitHub：<a href="https://github.com/youzan/vant-weapp" target="_blank" rel="noopener noreffer">https://github.com/youzan/vant-weapp</a></p>
<h3 id="3elementui">3、ElementUI</h3>
<p>饿了么开发的基于 Vue 2.0 的桌面端组件库</p>
<p>官网：<a href="https://element.eleme.cn" target="_blank" rel="noopener noreffer">https://element.eleme.cn</a></p>
<h2 id="wordpress-主题">WordPress 主题</h2>
<h3 id="1argon-theme">1、argon-theme</h3>
<p>博客、文章向主题</p>
<p>Github：<a href="https://github.com/solstice23/argon-theme" target="_blank" rel="noopener noreffer">https://github.com/solstice23/argon-theme</a></p>
<p>Demo：<a href="https://solstice23.top/archives/746" target="_blank" rel="noopener noreffer">https://solstice23.top/archives/746</a></p>
<h3 id="2puock">2、Puock</h3>
<p>博客、文章主题</p>
<p>Github：<a href="https://github.com/Licoy/wordpress-theme-puock" target="_blank" rel="noopener noreffer">https://github.com/Licoy/wordpress-theme-puock</a></p>
<p>Demo：<a href="https://www.licoy.cn" target="_blank" rel="noopener noreffer">https://www.licoy.cn</a></p>
<h3 id="3webstack">3、WebStack</h3>
<p>网址导航主题</p>
<p>Github：<a href="https://github.com/owen0o0/WebStack" target="_blank" rel="noopener noreffer">https://github.com/owen0o0/WebStack</a></p>
<h2 id="hugo-主题">Hugo 主题</h2>
<h3 id="1doit">1、DoIt</h3>
<p>个人博客主题</p>
<p>Github：<a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer">https://github.com/HEIGE-PCloud/DoIt</a></p>
<p>Demo：<a href="https://hugodoit.pages.dev/zh-cn/" target="_blank" rel="noopener noreffer">https://hugodoit.pages.dev/zh-cn/</a></p>
<h3 id="2hugo-theme-meme">2、hugo-theme-meme</h3>
<p>个人博客主题</p>
<p>Github：<a href="https://github.com/reuixiy/hugo-theme-meme" target="_blank" rel="noopener noreffer">https://github.com/reuixiy/hugo-theme-meme</a></p>
<p>Demo：<a href="https://io-oi.me/" target="_blank" rel="noopener noreffer">https://io-oi.me/</a></p>
<h2 id="javascript">JavaScript</h2>
<h3 id="1introjs">1、intro.js</h3>
<p>网站页面 / 新功能 引导流程插件</p>
<p>官网：<a href="http://introjs.com" target="_blank" rel="noopener noreffer">http://introjs.com</a></p>
<p>GitHub：<a href="https://github.com/usablica/intro.js" target="_blank" rel="noopener noreffer">https://github.com/usablica/intro.js</a></p>
<h3 id="2clipboardjs">2、clipboard.js</h3>
<p>js 实现一键复制文本到剪贴板插件</p>
<p>官网：<a href="https://clipboardjs.com" target="_blank" rel="noopener noreffer">https://clipboardjs.com</a></p>
<p>GitHub：<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener noreffer">https://github.com/zenorocha/clipboard.js</a></p>
<h3 id="3viewerjs">3、viewer.js</h3>
<p>js 图片浏览插件</p>
<p>官网：<a href="https://fengyuanchen.github.io/viewerjs" target="_blank" rel="noopener noreffer">https://fengyuanchen.github.io/viewerjs</a></p>
<p>Github：<a href="https://github.com/fengyuanchen/viewerjs" target="_blank" rel="noopener noreffer">https://github.com/fengyuanchen/viewerjs</a></p>
<h3 id="4contextjs">4、context.js</h3>
<p>右键菜单插件</p>
<p>官网：<a href="http://lab.jakiestfu.com/contextjs" target="_blank" rel="noopener noreffer">http://lab.jakiestfu.com/contextjs</a></p>
<p>Github：<a href="https://github.com/jakiestfu/Context.js" target="_blank" rel="noopener noreffer">https://github.com/jakiestfu/Context.js</a></p>
<h3 id="5momentjs">5、moment.js</h3>
<p>JavaScript 日期处理类库，多语言支持</p>
<p>官网：<a href="https://momentjs.com" target="_blank" rel="noopener noreffer">https://momentjs.com</a> / <a href="http://momentjs.cn" target="_blank" rel="noopener noreffer">http://momentjs.cn</a></p>
<h3 id="6highlightjs">6、highlight.js</h3>
<p>代码高亮 / 支持 189 种编程语言 / 95 种高亮样式</p>
<p>Github：<a href="https://github.com/highlightjs/highlight.js" target="_blank" rel="noopener noreffer">https://github.com/highlightjs/highlight.js</a></p>
<p>官网：<a href="https://highlightjs.org" target="_blank" rel="noopener noreffer">https://highlightjs.org</a> / <a href="https://highlightjs.org/static/demo" target="_blank" rel="noopener noreffer">https://highlightjs.org/static/demo</a></p>
<h3 id="7pangujs">7、Pangu.js</h3>
<p>中文字和英文、数字、符号之间自动插入空格</p>
<p>Github：<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener noreffer">https://github.com/vinta/pangu.js</a></p>
<p>官网：暂无</p>
<h2 id="m3u-直播源">M3U 直播源</h2>
<h3 id="1wtv">1、wtv</h3>
<p>解决电脑、手机看电视直播的苦恼，收集各种直播源，电视直播网站。建议配合 potplayer 使用。</p>
<p>Github：<a href="https://github.com/biancangming/wtv" target="_blank" rel="noopener noreffer">https://github.com/biancangming/wtv</a></p>
<h2 id="客户端软件">客户端软件</h2>
<h3 id="1contextmenumanager">1、ContextMenuManager</h3>
<p>一个纯粹的 Windows 右键菜单管理程序</p>
<p>Github：<a href="https://github.com/BluePointLilac/ContextMenuManager" target="_blank" rel="noopener noreffer">https://github.com/BluePointLilac/ContextMenuManager</a></p>
<p>官网：<a href="https://bluepointlilac.github.io/ContextMenuManager" target="_blank" rel="noopener noreffer">https://bluepointlilac.github.io/ContextMenuManager</a></p>
<h1 id="工具站点">工具站点</h1>
<h2 id="开发">开发</h2>
<h3 id="1requestcatchercom">1、requestcatcher.com</h3>
<p>Debug web hooks, http clients, etc.</p>
<p>Request Catcher will create a subdomain on which you can test an application. All requests sent to any path on the subdomain are forwarded to your browser in real time.</p>
<p>官网：<a href="https://requestcatcher.com" target="_blank" rel="noopener noreffer">https://requestcatcher.com</a></p>
<h3 id="2jsoncn">2、json.cn</h3>
<p>json 格式化</p>
<p>官网：<a href="http://json.cn" target="_blank" rel="noopener noreffer">http://json.cn</a></p>
<h3 id="3searchcode">3、searchcode</h3>
<p>是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。</p>
<p>官网：<a href="https://searchcode.com" target="_blank" rel="noopener noreffer">https://searchcode.com</a></p>
<p>设计
1、创客贴
付费网站，但提供一些免费资源，比较灵活的在线设计工具。风格比较偏向 MG 动画，可以搞出很花哨的 banner 和长图海报之类的，算是个不错的设计资源网站。</p>
<p>官网：<a href="https://www.chuangkit.com" target="_blank" rel="noopener noreffer">https://www.chuangkit.com</a></p>
<h2 id="书籍">书籍</h2>
<h3 id="1鸠摩搜索">1、鸠摩搜索</h3>
<p>鸠摩是一个电子书搜索引擎，界面简洁、内容纯净，专业而高效。</p>
<p>官网：<a href="https://www.jiumodiary.com" target="_blank" rel="noopener noreffer">https://www.jiumodiary.com</a></p>
<h3 id="2thefuture-书籍搜索">2、thefuture 书籍搜索</h3>
<p>小站，知名度不高，但试着搜索了几本书，感觉还挺好用。</p>
<p>官网：<a href="https://bks.thefuture.top" target="_blank" rel="noopener noreffer">https://bks.thefuture.top</a></p>
<h3 id="3z-library">3、z-library</h3>
<p>可以找到不少英文原版书籍</p>
<p>官网：<a href="https://zh.z-lib.org/" target="_blank" rel="noopener noreffer">https://zh.z-lib.org/</a></p>
<h3 id="4全国图书馆参考咨询联盟">4、全国图书馆参考咨询联盟</h3>
<p>由中国公共、教育、科技系统 图书馆合作建立的公益性服务机构，能找到不少书籍，但下载比较麻烦。</p>
<p>官网：<a href="http://www.ucdrs.superlib.net/" target="_blank" rel="noopener noreffer">http://www.ucdrs.superlib.net/</a></p>
<h2 id="生产力">生产力</h2>
<h3 id="1gitmind-在线思维导图">1、GitMind 在线思维导图</h3>
<p><a href="https://gitmind.cn" target="_blank" rel="noopener noreffer">https://gitmind.cn</a></p>
<h2 id="图像">图像</h2>
<h3 id="1ai-人工智能图片无损放大">1、AI 人工智能图片无损放大</h3>
<p><a href="https://bigjpg.com" target="_blank" rel="noopener noreffer">https://bigjpg.com</a></p>
<h3 id="2tinypng-图片在线压缩">2、tinypng 图片在线压缩</h3>
<p><a href="https://tinypng.com/" target="_blank" rel="noopener noreffer">https://tinypng.com/</a></p>
<h3 id="3squoosh谷歌图片在线压缩--开源">3、Squoosh（谷歌图片在线压缩 / 开源）</h3>
<p><a href="https://squoosh.app/" target="_blank" rel="noopener noreffer">https://squoosh.app/</a></p>
<h3 id="4消除图片中的背景--ai-自动抠图">4、消除图片中的背景 / AI 自动抠图</h3>
<p><a href="https://www.remove.bg/zh" target="_blank" rel="noopener noreffer">https://www.remove.bg/zh</a></p>
<h2 id="内容创作">内容创作</h2>
<h3 id="1emoji大全--emoji表情符号词典-">1、Emoji大全 | Emoji表情符号词典 📓</h3>
<p><a href="https://www.emojiall.com/zh-hans" target="_blank" rel="noopener noreffer">https://www.emojiall.com/zh-hans</a></p>
<h3 id="2deepl-翻译">2、DeepL 翻译</h3>
<p><a href="https://www.deepl.com/translator" target="_blank" rel="noopener noreffer">https://www.deepl.com/translator</a></p>
<h2 id="kms">KMS</h2>
<h3 id="1沧水-kms">1、沧水 KMS</h3>
<p><a href="https://kms.cangshui.net" target="_blank" rel="noopener noreffer">https://kms.cangshui.net</a></p>
<h3 id="2moerats-kms">2、moerats KMS</h3>
<p><a href="https://www.moerats.com/kms" target="_blank" rel="noopener noreffer">https://www.moerats.com/kms</a></p>
<h2 id="其他">其他</h2>
<h3 id="1台风路径查询">1、台风路径查询</h3>
<p><a href="http://typhoon.zjwater.gov.cn" target="_blank" rel="noopener noreffer">http://typhoon.zjwater.gov.cn</a></p>
<h3 id="2黑客模拟器">2、黑客模拟器</h3>
<p><a href="http://geektyper.com" target="_blank" rel="noopener noreffer">http://geektyper.com</a></p>
<h3 id="3世界护照大全">3、世界护照大全</h3>
<p><a href="https://www.passportindex.org/cn" target="_blank" rel="noopener noreffer">https://www.passportindex.org/cn</a></p>
<h3 id="4查无此人--ai-生成人脸">4、查无此人 / AI 生成人脸</h3>
<p><a href="https://thispersondoesnotexist.com" target="_blank" rel="noopener noreffer">https://thispersondoesnotexist.com</a></p>
<h3 id="5网页版-windows93">5、网页版 windows93</h3>
<p><a href="http://www.windows93.net" target="_blank" rel="noopener noreffer">http://www.windows93.net</a></p>
<h3 id="6假装系统在升级">6、假装系统在升级</h3>
<p><a href="http://fakeupdate.net" target="_blank" rel="noopener noreffer">http://fakeupdate.net</a></p>
<h2 id="好像有那么点用">好像有那么点用</h2>
<h3 id="1全历史">1、全历史</h3>
<p><a href="https://www.allhistory.com" target="_blank" rel="noopener noreffer">https://www.allhistory.com</a></p>
<h3 id="2西窗烛--古诗">2、西窗烛 / 古诗</h3>
<p><a href="http://lib.xcz.im/library" target="_blank" rel="noopener noreffer">http://lib.xcz.im/library</a></p>]]></description>
</item><item>
    <title>14、剑指 Offer 20. 表示数值的字符串</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/14.html</link>
    <pubDate>Wed, 15 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/14.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 48. 最长不含重复字符的子字符串</a> 难度中等</p>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p><strong>示例 1:</strong></p>
<pre tabindex="0"><code>输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre><p><strong>示例 2:</strong></p>
<pre tabindex="0"><code>输入: &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
</code></pre><p><strong>示例 3:</strong></p>
<pre tabindex="0"><code>输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。
</code></pre><p>提示：</p>
<ul>
<li><code>s.length &lt;= 40000</code></li>
</ul>
<p>注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21滑动窗口法">2.1、滑动窗口法</h2>
<h3 id="核心思路">核心思路：</h3>
<p>记 <code>left = 0</code> 为滑动窗口的左边界下标，<code>right = 0</code>为右边界下标。</p>
<p>借助哈希表，在遍历字符串 s 时，使用哈希表 map 记录各字符最后一次出现的索引位置。</p>
<p>在遍历过程中，不断右移滑动窗口的右下标 <code>right</code>，借助 <code>map</code> 判断 <code>s[right]</code> 字符是否已经遍历过。</p>
<p>根据 <code>s[right]</code> 是否为第一次出现，有以下 2 种情况：</p>
<ul>
<li>是：则 map 中不存在 <code>key = s[right]</code>，此时无需更新左边界 left；</li>
<li>否：则 map 中存在 <code>key = s[right]</code>，取 value ，得到 <code>s[right]</code> 末次出现的下标，记为 index 。更新左边界 left = Math.max ( index + 1, left ) ；</li>
</ul>
<p>更新 <code>s[right]</code> 末次出现的下标，记录滑动窗口的长度最大值 <code>right - left + 1</code> 即可。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N)</p>
<p><strong>空间复杂度</strong>：O(1)，字符的 ASCII 码范围为 00 ~ 127 ，哈希表 map 最多使用 O(128) = O(1) 大小的额外空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 遍历字符串 s 时，使用哈希表 map 统计各字符最后一次出现的索引位置
</span><span class="c1"></span>        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>

        <span class="c1">// left = 滑动窗口的左边界: result = 滑动窗口长度的最大值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="c1">// 遍历字符串 s
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 当前字符
</span><span class="c1"></span>            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>

            <span class="c1">// 如果 map 中存在 key = 当前字符
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 更新滑动窗口的左边界
</span><span class="c1"></span>                <span class="c1">// 左边界只允许向右移
</span><span class="c1"></span>                <span class="n">left</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">left</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// 更新当前字符末次出现的下标
</span><span class="c1"></span>            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">),</span> <span class="n">right</span><span class="o">);</span>

            <span class="c1">// 记录滑动窗口的长度最大值
</span><span class="c1"></span>            <span class="n">result</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/</a></p>
]]></description>
</item><item>
    <title>2FA 是什么？</title>
    <link>https://sugarless.top/posts/what-is-2fa.html</link>
    <pubDate>Wed, 15 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/what-is-2fa.html</guid>
    <description><![CDATA[<p>两步验证是什么东西？为什么当年的 QQ 令牌可以离线生成动态验证码？</p>
<h1 id="一2fa-是什么">一、2FA 是什么？</h1>
<p>2FA，2 Factor Authentication，双因子验证，是一种安全密码验证方式。区别于传统的密码验证，由于传统的密码验证是由一组静态信息组成，如：字符、图像、手势等，很容易被获取，相对不安全。2FA是基于时间、历史长度、实物（信用卡、SMS手机、令牌、指纹）等自然变量结合一定的加密算法组合出一组动态密码，一般每 30 / 60 秒刷新一次。不容易被获取和破解，相对安全。</p>
<p>以上是百度百科对 2FA 的描述，这么讲可能不太好理解。</p>
<p>一般来说，三种不同类型的证据，可以证明一个人的身份。</p>
<ul>
<li>
<p><strong>秘密信息</strong>：只有该用户知道、其他人不知道的某种信息，比如密码。</p>
</li>
<li>
<p><strong>个人物品</strong>：该用户的私人物品，比如身份证、钥匙。</p>
</li>
<li>
<p><strong>生理特征</strong>：该用户的遗传特征，比如指纹、相貌、虹膜等等。</p>
</li>
</ul>
<p>这些证据就称为三种&quot;因素&quot;（factor）。因素越多，证明力就越强，身份就越可靠。2FA 就是指，通过认证同时需要两个因素的证据。银行卡就是最常见的双因素认证。用户必须同时提供银行卡和密码，才能取到现金。</p>
<p>常用的双因素组合是密码 + 某种能代表个人身份的物品。比如网上银行的 U 盾，用户插上 U 盾，再输入密码，才能登录网上银行。</p>
<p>但是，用户不可能随时携带 U 盾，手机才是最好的替代品。于是就有了密码 + 手机的双因素认证方案。在注册新账号或敏感操作时，部分网站会要求用户输入密码后，还要提供网站发送给用户的手机短信验证码，以证明用户确实拥有该手机。</p>
<p>然而，短信验证码是不安全的，它容易被拦截和伪造，SIM 卡也可以克隆。已经有<a href="http://media.people.com.cn/n/2014/0227/c40606-24477072.html" target="_blank" rel="noopener noreffer">案例</a>，先伪造身份证，再申请一模一样的手机号码，把钱转走。因此，安全的双因素认证不是密码 + 短消息，而是下面要介绍的 <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm" target="_blank" rel="noopener noreffer">TOTP</a>。</p>
<p>在此之前，先给你举一个 2FA 在网站中的实际应用案例吧。</p>
<h1 id="二如何使用-2fa">二、如何使用 2FA？</h1>
<p>以 <a href="https://next.itellyou.cn/" target="_blank" rel="noopener noreffer">https://next.itellyou.cn/</a> 为例，账号启用 2FA 的步骤如下：</p>
<ol>
<li>
<p>点击双重验证 -&gt; 选择配置新的验证器，此时页面上已经显示了一串密钥和密钥的二维码。</p>
<blockquote>
<p>账号启用双重验证，服务器为该账号生成一个密钥</p>
</blockquote>
</li>
</ol>
<figure><a class="lightgallery" href="/post_images/image-20210913152802456.png" title="/post_images/image-20210913152802456.png" data-thumbnail="/post_images/image-20210913152802456.png" data-sub-html="<h2>配置双重验证</h2>">
        
    </a><figcaption class="image-caption">配置双重验证</figcaption>
    </figure>
<!-- raw HTML omitted -->
<ol>
<li>
<p>使用 2FA 验证器扫描密钥二维码，或手动输入密钥到 2FA 验证器中，此时你已经和服务器共同掌握了一把密钥。</p>
<blockquote>
<p>服务器将此密钥交给用户，用户将其填写到 2FA 验证器中</p>
</blockquote>
</li>
<li>
<p>将 2FA 验证器提供的 6 位数字验证码输入到提示框中，完成校验。</p>
<blockquote>
<p>服务器与用户的 2FA 验证器将使用此密钥进行哈希计算，得到时效性为 30 秒的 6 位数字验证码，如果两者计算出来的 6 位数字验证码相同，则认为用户已经成功配置了 2FA 验证器。</p>
<p>该用户在今后的登录行为中，除了需要提供密码外，还需要提供 2FA 验证器生成的 6 位验证码。</p>
</blockquote>
</li>
</ol>
<figure><a class="lightgallery" href="/post_images/image-20210913164434456.jpg" title="/post_images/image-20210913164434456.jpg" data-thumbnail="/post_images/image-20210913164434456.jpg" data-sub-html="<h2>动态验证码</h2>">
        
    </a><figcaption class="image-caption">动态验证码</figcaption>
    </figure>
<!-- raw HTML omitted -->
<ol>
<li>服务器提供一串代码作为最后的手段，一旦忘记密码或者遗失手机，想要恢复登录，就可以使用此恢复代码，一般来说这种恢复账号性质的代码都比较长，几乎不可能被暴力破解。</li>
</ol>
<p>下面我们回头继续讲 TOTP 算法。</p>
<h1 id="三totp-算法">三、TOTP 算法</h1>
<p>TOTP 的全称是&quot;基于时间的一次性密码&quot;（Time-based One-time Password）。它是公认的可靠解决方案，已经写入国际标准 <a href="https://tools.ietf.org/html/rfc6238" target="_blank" rel="noopener noreffer">RFC6238</a>。在配置完 2FA 后，使用 TOTP 算法生成 30 秒有效期的 6 位数字验证码，就不再需要与服务端通讯了，它可以在离线的环境下为用户提供一次性验证码。</p>
<p>还记得当年的 QQ 令牌吗？它在 2010 年 7 月 6 日正式发布，动态验证码有效期为 60 秒 ，最神奇的是它不需要联网。当时的我才十几岁，第一次见到这玩意时觉得非常神奇，其实它之所以能离线生成动态验证码的秘密就是 TOTP 算法。</p>
<h2 id="31如何生成一个-30-秒有效期的-6-位数字验证码">3.1、如何生成一个 30 秒有效期的 6 位数字验证码？</h2>
<p>那么<code>手机客户端</code>和<code>服务器</code>是如何保证在 <code>30</code> 秒期间都得到同一个 6 位数字验证码（哈希）呢？答案就是下面的公式。</p>
<p><code>TC = floor((unixtime(now) − unixtime(T0)) / TS)</code></p>
<p>上面的公式中，TC 表示一个时间计数器，<code>floor</code> 是向下取整函数，<code>unixtime(now)</code>是当前 Unix 时间戳，<code>unixtime(T0)</code>是约定的起始时间点的时间戳，默认是<code>0</code>，也就是1970年1月1日。TS 则是哈希有效期的时间长度，默认是30秒。因此，上面的公式就变成下面的形式。</p>
<p><code>TC = floor(unixtime(now) / 30)</code></p>
<p>所以，只要在 30 秒以内，TC 的值都是一样的。前提是服务器和手机的时间必须同步。接下来，就可以算出哈希了。</p>
<p><code>TOTP = HASH(SecretKey, TC)</code></p>
<p>上面代码中，<code>HASH</code>就是约定的哈希函数，默认是 SHA-1。</p>
<p>TOTP 有硬件生成器和软件生成器之分，都是采用上面的算法。</p>
<figure><a class="lightgallery" href="/post_images/image-20210913165747456.jpg" title="/post_images/image-20210913165747456.jpg" data-thumbnail="/post_images/image-20210913165747456.jpg" data-sub-html="<h2>TOTP 硬件生成器 - QQ令牌 1代</h2>">
        
    </a><figcaption class="image-caption">TOTP 硬件生成器 - QQ令牌 1代</figcaption>
    </figure>
<!-- raw HTML omitted -->
<figure><a class="lightgallery" href="/post_images/image-20210913165713456.jpg" title="/post_images/image-20210913165713456.jpg" data-thumbnail="/post_images/image-20210913165713456.jpg" data-sub-html="<h2>TOTP 硬件生成器 - QQ令牌 2代</h2>">
        
    </a><figcaption class="image-caption">TOTP 硬件生成器 - QQ令牌 2代</figcaption>
    </figure>
<!-- raw HTML omitted -->
<figure><a class="lightgallery" href="/post_images/image-20210913164434456.jpg" title="/post_images/image-20210913164434456.jpg" data-thumbnail="/post_images/image-20210913164434456.jpg" data-sub-html="<h2>TOTP 软件生成器 - Google Authenticator</h2>">
        
    </a><figcaption class="image-caption">TOTP 软件生成器 - Google Authenticator</figcaption>
    </figure>
<!-- raw HTML omitted -->
<h2 id="32totp-的-javascript-实现">3.2、TOTP 的 JavaScript 实现</h2>
<p>TOTP 很容易写，各个语言都有实现。下面我用 JavaScript 实现<a href="https://github.com/simontabor/2fa" target="_blank" rel="noopener noreffer"><code>2fa</code></a>来演示一下真实代码。</p>
<p>首先，安装这个模块。</p>
<p><code>npm install --save 2fa</code></p>
<p>然后，生成一个32位字符的密钥。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">tfa</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;2fa&#39;</span><span class="p">);</span>

<span class="nx">tfa</span><span class="p">.</span><span class="nx">generateKey</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// b5jjo0cz87d66mhwa9azplhxiao18zlx
</span></code></pre></div><p>现在就可以生成哈希了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">tc</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">/</span> <span class="mi">30</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">totp</span> <span class="o">=</span> <span class="nx">tfa</span><span class="p">.</span><span class="nx">generateCode</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">tc</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">totp</span><span class="p">);</span> <span class="c1">// 683464
</span></code></pre></div><h1 id="四总结">四、总结</h1>
<p>2FA 认证的优点在于，比单纯的密码登录安全得多。就算密码泄露，只要手机还在，账户就是安全的。各种密码破解方法，都对 2FA 认证无效。而且在完成最初的设置之后，2FA 验证器无需再与某处的服务器不间断的通讯来获取动态验证码，2FA 验证器计算动态验证码是完全可以离线的。举个比较极端的例子，你可以在飞机上使用 2FA 。</p>
<p>2FA 的缺点在于，登录多了一步，费时且麻烦，用户会感到不耐烦。而且，它也不意味着账户的绝对安全，入侵者依然可以通过盗取 cookie 或 token，劫持整个对话（session）。</p>
<p>双因素认证还有一个最大的问题，那就是帐户的恢复。</p>
<p>一旦忘记密码或者遗失手机，想要恢复登录，势必就要绕过双因素认证。当前具备 2FA 功能的各大网站给出的解决方案，普遍是提供一个<code>恢复代码</code>用来保证用户无法使用 2FA 时，仍然可以登录账号。为了避免被穷举，此<code>恢复代码</code>的长度普遍都较长，几十到上百个字符都是正常的。</p>
<p>因此，网站通常都会提醒用户保管好此<code>恢复代码</code>。</p>
<h1 id="五常用的-2fa-软件">五、常用的 2FA 软件</h1>
<ul>
<li>Google Authenticator</li>
<li>Microsoft Authenticator</li>
<li>1Password</li>
<li>authy</li>
<li>Duo Mobile</li>
<li>bitwarden</li>
<li>Aegis</li>
</ul>
<h1 id="ref">REF</h1>
<p>阮一峰 双因素认证（2FA）教程：<a href="http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html" target="_blank" rel="noopener noreffer">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a></p>
<p>百度百科 - 2FA：<a href="https://baike.baidu.com/item/2FA/14695073" target="_blank" rel="noopener noreffer">https://baike.baidu.com/item/2FA/14695073</a></p>
<p>两步验证的原理是什么：<a href="https://www.bilibili.com/video/BV1Rp411f78Q" target="_blank" rel="noopener noreffer">https://www.bilibili.com/video/BV1Rp411f78Q</a></p>
<p>说说「双因素认证」：<a href="https://www.bilibili.com/read/cv2138033/" target="_blank" rel="noopener noreffer">https://www.bilibili.com/read/cv2138033/</a></p>
<p>Next ITELL YOU：<a href="https://next.itellyou.cn/Identity/Account/Manage/EnableAuthenticator" target="_blank" rel="noopener noreffer">https://next.itellyou.cn/Identity/Account/Manage/EnableAuthenticator</a></p>
<p>常用 2FA 软件：<a href="https://hostloc.com/thread-721788-4-1.html" target="_blank" rel="noopener noreffer">https://hostloc.com/thread-721788-4-1.html</a></p>]]></description>
</item><item>
    <title>13、剑指 Offer 20. 表示数值的字符串</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/13.html</link>
    <pubDate>Mon, 13 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/13.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<h4 id="剑指-offer-20-表示数值的字符串httpsleetcode-cncomproblemsbiao-shi-shu-zhi-de-zi-fu-chuan-lcof-难度中等"><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 20. 表示数值的字符串</a> 难度中等</h4>
<p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p>
<p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>若干空格</li>
<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>
<li>（可选）一个 <code>'e'</code> 或 <code>'E'</code> ，后面跟着一个 <strong>整数</strong></li>
<li>若干空格</li>
</ol>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>
<li>下述格式之一：
<ol>
<li>至少一位数字，后面跟着一个点 <code>'.'</code></li>
<li>至少一位数字，后面跟着一个点 <code>'.'</code> ，后面再跟着至少一位数字</li>
<li>一个点 <code>'.'</code> ，后面跟着至少一位数字</li>
</ol>
</li>
</ol>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>
<li>至少一位数字</li>
</ol>
<p>部分<strong>数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li>
</ul>
<p>部分<strong>非数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;0&quot;
输出：true
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;e&quot;
输出：false
</code></pre><p><strong>示例 3：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;.&quot;
输出：false
</code></pre><p><strong>示例 4：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;    .1  &quot;
输出：true
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>'+'</code> ，减号 <code>'-'</code> ，空格 <code>' '</code> 或者点 <code>'.'</code> 。</li>
</ul>
<h1 id="二解法">二、解法</h1>
<h2 id="21确定有限状态自动机官方题解">2.1、确定有限状态自动机（官方题解）</h2>
<h3 id="核心思路">核心思路</h3>
<p><strong>预备知识</strong></p>
<p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：</p>
<p>有一个特殊的状态，被称作「初始状态」。
还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。
起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。</p>
<p>注意：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。</p>
<p>一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。</p>
<p>自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。</p>
<p>自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。</p>
<p><strong>问题描述</strong></p>
<p>在 <a href="https://en.cppreference.com/w/cpp/language/floating_literal" target="_blank" rel="noopener noreffer">C++ 文档</a> 中，描述了一个合法的数值字符串应当具有的格式。具体而言，它包含以下部分：</p>
<p>符号位，即 ++、-− 两种符号
整数部分，即由若干字符 0-90−9 组成的字符串
小数点
小数部分，其构成与整数部分相同
指数部分，其中包含开头的字符 \text{e}e（大写小写均可）、可选的符号位，和整数部分
相比于 C++ 文档而言，本题还有一点额外的不同，即允许字符串首末两端有一些额外的空格。</p>
<p>在上面描述的五个部分中，每个部分都不是必需的，但也受一些额外规则的制约，如：</p>
<p>如果符号位存在，其后面必须跟着数字或小数点。
小数点的前后两侧，至少有一侧是数字。</p>
<p><strong>思路与算法</strong></p>
<p>根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：</p>
<p>起始的空格
符号位
整数部分
左侧有整数的小数点
左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）
小数部分
字符 e
指数部分的符号位
指数部分的整数部分
末尾的空格
下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 1，而「接受状态」的集合则为状态 3、状态 4、状态 6、状态 9 以及状态 10。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。</p>
<p>最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来：</p>
<a class="lightgallery" href="/post_images/image-20210913110127164.png" title="/post_images/image-20210913110127164.png" data-thumbnail="/post_images/image-20210913110127164.png">
        
    </a>
<!-- raw HTML omitted -->
<p>比较上图与「预备知识」一节中对自动机的描述，可以看出有一点不同：</p>
<p>我们没有单独地考虑每种字符，而是划分为若干类。由于全部 10 个数字字符彼此之间都等价，因此只需定义一种统一的「数字」类型即可。对于正负号也是同理。
在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n)，其中 n 为字符串的长度。我们需要遍历字符串的每个字符，其中状态转移所需的时间复杂度为 O(1)。</p>
<p><strong>空间复杂度</strong>：O(1)，只需要创建固定大小的状态转移表。</p>
<h3 id="code">Code：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">// 有限状态集合
</span><span class="c1"></span>    <span class="kd">enum</span> <span class="n">State</span> <span class="o">{</span>
        <span class="c1">// 起始的空格
</span><span class="c1"></span>        <span class="n">STATE_INITIAL</span><span class="o">,</span>
        <span class="c1">// 整数部分符号位
</span><span class="c1"></span>        <span class="n">STATE_INT_SIGN</span><span class="o">,</span>
        <span class="c1">// 整数部分
</span><span class="c1"></span>        <span class="n">STATE_INTEGER</span><span class="o">,</span>
        <span class="c1">// 左侧有整数的小数点
</span><span class="c1"></span>        <span class="n">STATE_POINT</span><span class="o">,</span>
        <span class="c1">// 左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）
</span><span class="c1"></span>        <span class="n">STATE_POINT_WITHOUT_INT</span><span class="o">,</span>
        <span class="c1">// 小数部分
</span><span class="c1"></span>        <span class="n">STATE_FRACTION</span><span class="o">,</span>
        <span class="c1">// 字符 e
</span><span class="c1"></span>        <span class="n">STATE_EXP</span><span class="o">,</span>
        <span class="c1">// 指数部分的符号位
</span><span class="c1"></span>        <span class="n">STATE_EXP_SIGN</span><span class="o">,</span>
        <span class="c1">// 指数部分的整数部分
</span><span class="c1"></span>        <span class="n">STATE_EXP_NUMBER</span><span class="o">,</span>
        <span class="c1">// 末尾的空格
</span><span class="c1"></span>        <span class="n">STATE_END</span>
    <span class="o">}</span>

    <span class="c1">// 字符类型集合
</span><span class="c1"></span>    <span class="kd">enum</span> <span class="n">CharType</span> <span class="o">{</span>
        <span class="c1">// 数字
</span><span class="c1"></span>        <span class="n">CHAR_NUMBER</span><span class="o">,</span>
        <span class="c1">// 字符 e
</span><span class="c1"></span>        <span class="n">CHAR_EXP</span><span class="o">,</span>
        <span class="c1">// 小数点
</span><span class="c1"></span>        <span class="n">CHAR_POINT</span><span class="o">,</span>
        <span class="c1">// 正负号
</span><span class="c1"></span>        <span class="n">CHAR_SIGN</span><span class="o">,</span>
        <span class="c1">// 空格
</span><span class="c1"></span>        <span class="n">CHAR_SPACE</span><span class="o">,</span>
        <span class="c1">// 非法字符
</span><span class="c1"></span>        <span class="n">CHAR_ILLEGAL</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 状态机
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">State</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;&gt;</span> <span class="n">transfer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">State</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;&gt;();</span>


        <span class="c1">// 空格（初始状态） 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">initialMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="c1">// 空格
</span><span class="c1"></span>            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INITIAL</span><span class="o">);</span>
            <span class="c1">// 整数
</span><span class="c1"></span>            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span><span class="o">);</span>
            <span class="c1">// 小数点
</span><span class="c1"></span>            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_POINT</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT_WITHOUT_INT</span><span class="o">);</span>
            <span class="c1">// 正负号
</span><span class="c1"></span>            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SIGN</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INT_SIGN</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_INITIAL</span><span class="o">,</span> <span class="n">initialMap</span><span class="o">);</span>


        <span class="c1">// 整数部分符号位 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">intSignMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_POINT</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT_WITHOUT_INT</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_INT_SIGN</span><span class="o">,</span> <span class="n">intSignMap</span><span class="o">);</span>


        <span class="c1">// 整数部分 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">integerMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_EXP</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_POINT</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span><span class="o">,</span> <span class="n">integerMap</span><span class="o">);</span>

        <span class="c1">// 左侧有整数的小数点 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">pointMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_EXP</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT</span><span class="o">,</span> <span class="n">pointMap</span><span class="o">);</span>

        <span class="c1">// 左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分) 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">pointWithoutIntMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT_WITHOUT_INT</span><span class="o">,</span> <span class="n">pointWithoutIntMap</span><span class="o">);</span>

        <span class="c1">// 小数部分
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">fractionMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_EXP</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span><span class="o">,</span> <span class="n">fractionMap</span><span class="o">);</span>

        <span class="c1">// 字符 e 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">expMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SIGN</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_SIGN</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP</span><span class="o">,</span> <span class="n">expMap</span><span class="o">);</span>

        <span class="c1">// 指数部分的符号位 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">expSignMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_SIGN</span><span class="o">,</span> <span class="n">expSignMap</span><span class="o">);</span>

        <span class="c1">// 指数部分的整数部分 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">expNumberMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span><span class="o">,</span> <span class="n">expNumberMap</span><span class="o">);</span>

        <span class="c1">// 末尾的空格 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">endMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">,</span> <span class="n">endMap</span><span class="o">);</span>


        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// 初始状态
</span><span class="c1"></span>        <span class="n">State</span> <span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INITIAL</span><span class="o">;</span>

        <span class="c1">// 循环处理每个字符, 模拟状态转移
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 获取当前字符的类型
</span><span class="c1"></span>            <span class="n">CharType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">toCharType</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>

            <span class="k">if</span> <span class="o">(!</span><span class="n">transfer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">state</span><span class="o">).</span><span class="na">containsKey</span><span class="o">(</span><span class="n">type</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">transfer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">state</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">type</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 获取字符的类型
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">CharType</span> <span class="nf">toCharType</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;e&#39;</span> <span class="o">||</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_EXP</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_POINT</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SIGN</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_ILLEGAL</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22确定有限状态自动机评论区">2.2、确定有限状态自动机（评论区）</h2>
<h3 id="核心思路-1">核心思路</h3>
<p>本题使用有限状态自动机。根据字符类型和合法数值的特点，先定义状态，再画出状态转移图，最后编写代码即可。</p>
<p><strong>字符类型</strong>：</p>
<p>空格 「 」、数字「 0—9 」 、正负号 「 +− 」 、小数点 「 . 」 、幂符号 「 eE 」 。</p>
<p><strong>状态定义</strong>：</p>
<p>按照字符串从左到右的顺序，定义以下 9 种状态。</p>
<ul>
<li>开始的空格</li>
<li>幂符号前的正负号</li>
<li>小数点前的数字</li>
<li>小数点、小数点后的数字</li>
<li>当小数点前为空格时，小数点、小数点后的数字</li>
<li>幂符号</li>
<li>幂符号后的正负号</li>
<li>幂符号后的数字</li>
<li>结尾的空格</li>
</ul>
<p><strong>结束状态</strong>：</p>
<p>合法的结束状态有 2, 3, 7, 8 。</p>
<a class="lightgallery" href="/post_images/image-20210913105508562.png" title="/post_images/image-20210913105508562.png" data-thumbnail="/post_images/image-20210913105508562.png">
        
    </a>
<!-- raw HTML omitted -->
<h3 id="复杂度分析-1">复杂度分析</h3>
<p><strong>时间复杂度</strong>：其中 N 为字符串 s 的长度，判断需遍历字符串，每轮状态转移的使用 O(1) 时间。</p>
<p><strong>空间复杂度</strong>：states 和 p 使用常数大小的额外空间。</p>
<h3 id="code-1">Code：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HashMap</span><span class="o">[]</span> <span class="n">states</span> <span class="o">=</span> <span class="o">{</span>
                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;s&#39;</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">2</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="n">4</span><span class="o">);</span> <span class="o">}},</span> <span class="c1">// 0. start with &#39;blank&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">2</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="n">4</span><span class="o">);</span> <span class="o">}},</span>                           <span class="c1">// 1. &#39;sign&#39; before &#39;e&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">2</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="n">3</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;e&#39;</span><span class="o">,</span> <span class="n">5</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">8</span><span class="o">);</span> <span class="o">}},</span> <span class="c1">// 2. &#39;digit&#39; before &#39;dot&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">3</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;e&#39;</span><span class="o">,</span> <span class="n">5</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">8</span><span class="o">);</span> <span class="o">}},</span>              <span class="c1">// 3. &#39;digit&#39; after &#39;dot&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">3</span><span class="o">);</span> <span class="o">}},</span>                                        <span class="c1">// 4. &#39;digit&#39; after &#39;dot&#39; (‘blank’ before &#39;dot&#39;)
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;s&#39;</span><span class="o">,</span> <span class="n">6</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">7</span><span class="o">);</span> <span class="o">}},</span>                           <span class="c1">// 5. &#39;e&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">7</span><span class="o">);</span> <span class="o">}},</span>                                        <span class="c1">// 6. &#39;sign&#39; after &#39;e&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">7</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">8</span><span class="o">);</span> <span class="o">}},</span>                           <span class="c1">// 7. &#39;digit&#39; after &#39;e&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">8</span><span class="o">);</span> <span class="o">}}</span>                                         <span class="c1">// 8. end with &#39;blank&#39;
</span><span class="c1"></span>        <span class="o">};</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="sc">&#39;d&#39;</span><span class="o">;</span>       <span class="c1">// digit
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="sc">&#39;s&#39;</span><span class="o">;</span>  <span class="c1">// sign
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;e&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="sc">&#39;e&#39;</span><span class="o">;</span>  <span class="c1">// e or E
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>    <span class="c1">// dot, blank
</span><span class="c1"></span>            <span class="k">else</span> <span class="n">t</span> <span class="o">=</span> <span class="sc">&#39;?&#39;</span><span class="o">;</span>                           <span class="c1">// unknown
</span><span class="c1"></span>            <span class="k">if</span><span class="o">(!</span><span class="n">states</span><span class="o">[</span><span class="n">p</span><span class="o">].</span><span class="na">containsKey</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">states</span><span class="o">[</span><span class="n">p</span><span class="o">].</span><span class="na">get</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">p</span> <span class="o">==</span> <span class="n">2</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">3</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">7</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">8</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="23常规解法">2.3、常规解法</h2>
<h3 id="核心思路-2">核心思路</h3>
<blockquote>
<p>什么有限状态自动机的我不太懂，常规解法可以做就不想搞这种可能只有这道题会用到的解法。</p>
</blockquote>
<p>我首先想到的是判断否 false 而不是判断是 true，毕竟有这么多条件满足才能判断 true，但是只要有一个条件不满足就可以判断 false，最后代码的效率也还可以，那么接下来进入正题吧：</p>
<ol>
<li>
<p>首先定义了四个flag，对应四种字符</p>
<ul>
<li>是否有数字：hasNum</li>
<li>是否有e：hasE</li>
<li>是否有正负符号：hasSign</li>
<li>是否有点：hasDot</li>
</ul>
</li>
<li>
<p>其余还定义了字符串长度 n 以及字符串索引 index</p>
</li>
<li>
<p>先处理一下开头的空格，index 相应的后移</p>
</li>
<li>
<p>然后进入循环，遍历字符串</p>
<ul>
<li>如果当前字符 c 是数字：将 hasNum 置为 true ，index 往后移动一直到非数字或遍历到末尾位置；如果已遍历到末尾 ( index == n ) ，结束循环</li>
<li>如果当前字符 c 是 &lsquo;e&rsquo; 或 &lsquo;E&rsquo; ：如果 e 已经出现或者当前 e 之前没有出现过数字，返回 fasle ；否则令 hasE = true ，并且将其他 3 个 flag 全部置为 false ，因为要开始遍历 e 后面的新数字了</li>
<li>如果当前字符 c 是 + 或-：如果已经出现过 + 或 - 或者已经出现过数字或者已经出现过 &lsquo;.&rsquo; ，返回 flase ；否则令 hasSign = true</li>
<li>如果当前字符 c 是 &lsquo;.&rsquo; ：如果已经出现过 &lsquo;.&rsquo; 或者已经出现过 &lsquo;e&rsquo; 或 &lsquo;E&rsquo; ，返回 false ；否则令 hasDot = true</li>
<li>如果当前字符 c 是 ' ' ：结束循环，因为可能是末尾的空格了，但也有可能是字符串中间的空格，在循环外继续处理</li>
<li>如果当前字符 c 是除了上面 5 种情况以外的其他字符，直接返回 false</li>
</ul>
</li>
<li>
<p>处理空格，index 相应的后移</p>
</li>
<li>
<p>如果当前索引 index 与字符串长度相等，说明遍历到了末尾，但是还要满足 hasNum 为 true 才可以最终返回 true ，因为如果字符串里全是符号没有数字的话是不行的，而且 e 后面没有数字也是不行的，但是没有符号是可以的，所以 4 个 flag 里只要判断一下 hasNum 就行；所以最后返回的是 hasNum &amp;&amp; index == n</p>
</li>
<li>
<p>如果字符串中间有空格，按以上思路是无法遍历到末尾的，index 不会与 n 相等，返回的就是 false</p>
</li>
</ol>
<h3 id="复杂度分析-2">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n)</p>
<p><strong>空间复杂度</strong>：O(1)</p>
<h3 id="code-2">Code：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">hasNum</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">hasE</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">hasSign</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">hasDot</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span>
            <span class="n">index</span><span class="o">++;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="o">){</span>
                <span class="n">index</span><span class="o">++;</span>
                <span class="n">hasNum</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;e&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hasE</span> <span class="o">||</span> <span class="o">!</span><span class="n">hasNum</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">hasE</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">hasNum</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="n">hasSign</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="n">hasDot</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hasSign</span> <span class="o">||</span> <span class="n">hasNum</span> <span class="o">||</span> <span class="n">hasDot</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">hasSign</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hasDot</span> <span class="o">||</span> <span class="n">hasE</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">hasDot</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">index</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span>
            <span class="n">index</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">hasNum</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">==</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/</a></p>
<p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/</a></p>
<p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/jian-zhi-offer-20-biao-shi-shu-zhi-de-zi-060v/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/jian-zhi-offer-20-biao-shi-shu-zhi-de-zi-060v/</a></p>
]]></description>
</item><item>
    <title>知乎就月饼吃坏肚子致歉</title>
    <link>https://sugarless.top/posts/news/zhihu-apologizes-for-the-mooncake-incident.html</link>
    <pubDate>Wed, 08 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/news/zhihu-apologizes-for-the-mooncake-incident.html</guid>
    <description><![CDATA[<p>知乎送给大 V 的月饼吃了之后拉肚子，原因是这批月饼用的糖醇（麦芽糖醇）代替糖，而摄入大量糖醇会导致腹泻，有些人喝太多代糖饮料会腹泻也是同样原因，这回真“泻药”了。。。</p>
<p>不得不说，月饼的外包装还是挺好看的。</p>
<figure><a class="lightgallery" href="/post_images/image-20210909161118120.png" title="/post_images/image-20210909161118120.png" data-thumbnail="/post_images/image-20210909161118120.png" data-sub-html="<h2>from 即刻 - 油百万</h2>">
        
    </a><figcaption class="image-caption">from 即刻 - 油百万</figcaption>
    </figure>
<!-- raw HTML omitted -->
<figure><a class="lightgallery" href="/post_images/image-20210909160738423.png" title="/post_images/image-20210909160738423.png" data-thumbnail="/post_images/image-20210909160738423.png" data-sub-html="<h2>from 即刻 - 油百万</h2>">
        
    </a><figcaption class="image-caption">from 即刻 - 油百万</figcaption>
    </figure>
<!-- raw HTML omitted -->
<figure><a class="lightgallery" href="/post_images/image-20210909160914669.png" title="/post_images/image-20210909160914669.png" data-thumbnail="/post_images/image-20210909160914669.png" data-sub-html="<h2>from 即刻 - 油百万</h2>">
        
    </a><figcaption class="image-caption">from 即刻 - 油百万</figcaption>
    </figure>
<!-- raw HTML omitted -->
<figure><a class="lightgallery" href="/post_images/image-20210909160941837.png" title="/post_images/image-20210909160941837.png" data-thumbnail="/post_images/image-20210909160941837.png" data-sub-html="<h2>from 即刻 - 油百万</h2>">
        
    </a><figcaption class="image-caption">from 即刻 - 油百万</figcaption>
    </figure>
<!-- raw HTML omitted -->
<figure><a class="lightgallery" href="/post_images/image-20210913115606456.png" title="/post_images/image-20210913115606456.png" data-thumbnail="/post_images/image-20210913115606456.png" data-sub-html="<h2>from 即刻 - 油百万</h2>">
        
    </a><figcaption class="image-caption">from 即刻 - 油百万</figcaption>
    </figure>
<!-- raw HTML omitted -->
<p>知乎官方微博原文截图</p>
<figure><a class="lightgallery" href="/post_images/image-20210909020717395.png" title="/post_images/image-20210909020717395.png" data-thumbnail="/post_images/image-20210909020717395.png" data-sub-html="<h2>官方微博账号道歉声明</h2>">
        
    </a><figcaption class="image-caption">官方微博账号道歉声明</figcaption>
    </figure>
<!-- raw HTML omitted -->
<p>微博原文中的 P3，是此次月饼采销的负责人发言。</p>
<figure><a class="lightgallery" href="/post_images/0024UdtXly1gu9gw8412xj60t416ctfg02.jpg" title="/post_images/0024UdtXly1gu9gw8412xj60t416ctfg02.jpg" data-thumbnail="/post_images/0024UdtXly1gu9gw8412xj60t416ctfg02.jpg" data-sub-html="<h2>此次月饼采销负责人发言</h2>">
        
    </a><figcaption class="image-caption">此次月饼采销负责人发言</figcaption>
    </figure>
<!-- raw HTML omitted -->
<p>在官方出面道歉前，其实已经有知乎用户给出了相关解释。</p>
<figure><a class="lightgallery" href="/post_images/0d95b77fef1102bed4ec663f4986e6af2050e42f.jpg@518w.webp" title="/post_images/0d95b77fef1102bed4ec663f4986e6af2050e42f.jpg@518w.webp" data-thumbnail="/post_images/0d95b77fef1102bed4ec663f4986e6af2050e42f.jpg@518w.webp" data-sub-html="<h2>知乎用户爆料</h2>">
        
    </a><figcaption class="image-caption">知乎用户爆料</figcaption>
    </figure>
<!-- raw HTML omitted -->
<p>官方账号道歉声明微博下对控评不满的网友们。</p>
<figure><a class="lightgallery" href="/post_images/242aade9ae3be74133a3afe98cdbff51e5f5bb76.jpg@518w.webp" title="/post_images/242aade9ae3be74133a3afe98cdbff51e5f5bb76.jpg@518w.webp" data-thumbnail="/post_images/242aade9ae3be74133a3afe98cdbff51e5f5bb76.jpg@518w.webp" data-sub-html="<h2>网友们</h2>">
        
    </a><figcaption class="image-caption">网友们</figcaption>
    </figure>
<!-- raw HTML omitted -->
<figure><a class="lightgallery" href="/post_images/image-20210909021633620.png" title="/post_images/image-20210909021633620.png" data-thumbnail="/post_images/image-20210909021633620.png" data-sub-html="<h2>网友们</h2>">
        
    </a><figcaption class="image-caption">网友们</figcaption>
    </figure>
<!-- raw HTML omitted -->
<figure><a class="lightgallery" href="/post_images/image-20210909021829820.png" title="/post_images/image-20210909021829820.png" data-thumbnail="/post_images/image-20210909021829820.png" data-sub-html="<h2>网友们</h2>">
        
    </a><figcaption class="image-caption">网友们</figcaption>
    </figure>
<!-- raw HTML omitted -->
<h1 id="ref">REF</h1>
<p>即刻 - 油百万：<a href="https://m.okjike.com/originalPosts/6136198602cb2b0010e286d9" target="_blank" rel="noopener noreffer">https://m.okjike.com/originalPosts/6136198602cb2b0010e286d9</a></p>
<p>即刻 - 油百万：<a href="https://m.okjike.com/originalPosts/613d9d6a67d511001031ad9c" target="_blank" rel="noopener noreffer">https://m.okjike.com/originalPosts/613d9d6a67d511001031ad9c</a></p>
<p>微博 - 知乎官微道歉声明原文：<a href="https://weibo.com/1904769205/KxfvMybtj" target="_blank" rel="noopener noreffer">https://weibo.com/1904769205/KxfvMybtj</a></p>
]]></description>
</item><item>
    <title>12、剑指 Offer 10- I. 斐波那契数列</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/12.html</link>
    <pubDate>Tue, 07 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/12.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 10- I. 斐波那契数列</a> 难度简单</p>
<p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<pre tabindex="0"><code>F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
</code></pre><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：n = 2
输出：1
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：n = 5
输出：5
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<h1 id="二解法">二、解法</h1>
<h2 id="21动态规划">2.1、动态规划</h2>
<h3 id="核心思路">核心思路：</h3>
<p>斐波那契数的边界条件是 F(0)=0 和 F(1)=1。当 n&gt;1 时，每一项的和都等于前两项的和，因此有如下递推关系：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain">F(n)=F(n-1)+F(n-2)
</code></pre></div><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 F(0) 和 F(1)。</p>
<p>计算过程中，答案需要取模 1e9+7。</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<p><strong>时间复杂度 O(N)</strong>：计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1)。</p>
<p><strong>空间复杂度 O(1)</strong>：几个标志变量使用常数大小的额外空间。</p>
<h3 id="code">Code：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">MOD</span> <span class="o">=</span> <span class="n">1000000007</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span> 
            <span class="n">q</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span> 
            <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="o">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22矩阵快速幂待续">2.2、矩阵快速幂（待续）</h2>
<p>动态规划的时间复杂度是 O(n)。使用矩阵快速幂的方法可以降低时间复杂度。</p>
<h3 id="核心思路-1">核心思路：</h3>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<p><strong>时间复杂度</strong>：O(log n)。</p>
<p><strong>空间复杂度</strong>：O(1)。</p>
<h3 id="code-1">Code：</h3>
<h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/fei-bo-na-qi-shu-lie-by-leetcode-solutio-hbss/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/fei-bo-na-qi-shu-lie-by-leetcode-solutio-hbss/</a></p>
]]></description>
</item><item>
    <title>10、剑指 Offer 04. 二维数组中的查找</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/10.html</link>
    <pubDate>Sat, 04 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/10.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 04. 二维数组中的查找</a> 难度中等</p>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例:</strong></p>
<p>现有矩阵 matrix 如下：</p>
<pre tabindex="0"><code>[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
</code></pre><p>给定 target = <code>5</code>，返回 <code>true</code>。</p>
<p>给定 target = <code>20</code>，返回 <code>false</code>。</p>
<p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= n &lt;= 1000
0 &lt;= m &lt;= 1000
</code></pre><p>**注意：**本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21旋转法线性查找">2.1、旋转法（线性查找）</h2>
<h3 id="核心思想">核心思想：</h3>
<p>如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。</p>
<p></p>
<p>“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，也就是上图标注蓝色的 3 和 7，实际上以这两个元素为起点搜索都可以。</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<p><strong>时间复杂度</strong>：O(M+N)，其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。</p>
<p><strong>空间复杂度</strong>：O(1)， <code>i</code>, <code>j</code>  指针使用常数大小额外空间。</p>
<h3 id="代码">代码：</h3>
<p>以左下角为起点，向上搜索</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findNumberIn2DArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 将左下角元素作为起点（初始下标）
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="c1">// 循环寻找
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">--;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>或以右上角为起点，向下搜索</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findNumberIn2DArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 将右上角元素作为起点（初始下标）
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>

        <span class="c1">// 循环寻找
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">--;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22暴力法">2.2、暴力法</h2>
<h3 id="核心思想-1">核心思想：</h3>
<p>如果不考虑二维数组排好序的特点，则直接遍历整个二维数组的每一个元素，判断目标值是否在二维数组中存在。</p>
<p>依次遍历二维数组的每一行和每一列。如果找到一个元素等于目标值，则返回 true。如果遍历完毕仍未找到等于目标值的元素，则返回 false。</p>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<p><strong>时间复杂度</strong>：O(nm)。二维数组中的每个元素都被遍历，因此时间复杂度为二维数组的大小。</p>
<p><strong>空间复杂度</strong>：O(1)。</p>
<h3 id="代码-1">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findNumberIn2DArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 处理边界条件
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span> <span class="o">||</span> <span class="n">matrix</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 获取矩阵的行列值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// 遍历矩阵每个元素查找
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">columns</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/</a></p>
<p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/</a></p>
]]></description>
</item><item>
    <title>11、剑指 Offer 29. 顺时针打印矩阵</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/11.html</link>
    <pubDate>Sat, 04 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/11.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 29. 顺时针打印矩阵</a> 难度简单</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
<p>注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21四相边界法">2.1、四相边界法</h2>
<h3 id="核心思想">核心思想：</h3>
<p>已知顺时针打印矩阵的顺序是 <strong>“从左向右、从上向下、从右向左、从下向上”</strong> 循环，考虑设定矩阵的“左、上、右、下”四个边界，模拟以上矩阵遍历顺序。</p>
<ul>
<li>上边界 ( top )、下边界 ( bottom )；</li>
<li>左边界 ( left )、右边界 ( right )；</li>
</ul>
<table>
<thead>
<tr>
<th>打印方向</th>
<th>1. 根据边界打印</th>
<th style="text-align:left">2. 边界向内收缩</th>
<th>3. 是否打印完毕</th>
</tr>
</thead>
<tbody>
<tr>
<td>从左向右</td>
<td>左边界<code>l</code> ，右边界 <code>r</code></td>
<td style="text-align:left">上边界 <code>t</code> 加 11</td>
<td>是否 <code>t &gt; b</code></td>
</tr>
<tr>
<td>从上向下</td>
<td>上边界 <code>t</code> ，下边界<code>b</code></td>
<td style="text-align:left">右边界 <code>r</code> 减 11</td>
<td>是否 <code>l &gt; r</code></td>
</tr>
<tr>
<td>从右向左</td>
<td>右边界 <code>r</code> ，左边界<code>l</code></td>
<td style="text-align:left">下边界 <code>b</code> 减 11</td>
<td>是否 <code>t &gt; b</code></td>
</tr>
<tr>
<td>从下向上</td>
<td>下边界 <code>b</code> ，上边界<code>t</code></td>
<td style="text-align:left">左边界 <code>l</code> 加 11</td>
<td>是否 <code>l &gt; r</code></td>
</tr>
</tbody>
</table>
<h3 id="复杂度分析">复杂度分析：</h3>
<p><strong>时间复杂度</strong>：O(MN)， M, N 分别为矩阵行数和列数。</p>
<p><strong>空间复杂度</strong>：O(1)， 四个边界 <code>l</code> , <code>r</code> , <code>t</code> , <code>b</code> 使用常数大小的 <strong>额外</strong> 空间（ <code>res</code> 为必须使用的空间）。</p>
<h3 id="代码">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">spiralOrder</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[(</span><span class="n">r</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">1</span><span class="o">)];</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">res</span><span class="o">[</span><span class="n">x</span><span class="o">++]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">t</span><span class="o">][</span><span class="n">i</span><span class="o">];</span> <span class="c1">// left to right.
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(++</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">res</span><span class="o">[</span><span class="n">x</span><span class="o">++]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">r</span><span class="o">];</span> <span class="c1">// top to bottom.
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="o">--</span><span class="n">r</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>
                <span class="n">res</span><span class="o">[</span><span class="n">x</span><span class="o">++]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">i</span><span class="o">];</span> <span class="c1">// right to left.
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="o">--</span><span class="n">b</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>
                <span class="n">res</span><span class="o">[</span><span class="n">x</span><span class="o">++]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">l</span><span class="o">];</span> <span class="c1">// bottom to top.
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(++</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22辅助矩阵法">2.2、辅助矩阵法</h2>
<h3 id="核心思想-1">核心思想：</h3>
<p>可以模拟打印矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。</p>
<p>判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。</p>
<p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。</p>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<p><strong>时间复杂度</strong>：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</p>
<p><strong>空间复杂度</strong>：O(mn)，需要创建一个大小为 m×n 的矩阵 visited 记录每个位置是否被访问过。</p>
<h3 id="代码-1">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">spiralOrder</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 边界条件
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span> <span class="o">||</span> <span class="n">matrix</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// 获取矩阵的行列数
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// 构造辅助矩阵
</span><span class="c1"></span>        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">rows</span><span class="o">][</span><span class="n">columns</span><span class="o">];</span>
        <span class="c1">// 计算矩阵元素个数总和
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">columns</span><span class="o">;</span>

        <span class="c1">// 答案
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">total</span><span class="o">];</span>

        <span class="c1">// 当前坐标
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="c1">// 方向
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">directions</span> <span class="o">=</span> <span class="o">{{</span><span class="n">0</span><span class="o">,</span> <span class="n">1</span><span class="o">},</span> <span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">0</span><span class="o">},</span> <span class="o">{</span><span class="n">0</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">},</span> <span class="o">{-</span><span class="n">1</span><span class="o">,</span> <span class="n">0</span><span class="o">}};</span>
        <span class="c1">// 当前是哪个方向
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">directionIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 将当前元素写入 result
</span><span class="c1"></span>            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">];</span>

            <span class="c1">// 在辅助矩阵中标注已访问过
</span><span class="c1"></span>            <span class="n">visited</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="c1">// 计算当前方向的下一个坐标
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">nextRow</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">directions</span><span class="o">[</span><span class="n">directionIndex</span><span class="o">][</span><span class="n">0</span><span class="o">],</span> <span class="n">nextColumn</span> <span class="o">=</span> <span class="n">column</span> <span class="o">+</span> <span class="n">directions</span><span class="o">[</span><span class="n">directionIndex</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
            <span class="c1">// 判断下一个坐标是否超限或已被访问过
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">nextRow</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">nextRow</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="o">||</span> <span class="n">nextColumn</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">nextColumn</span> <span class="o">&gt;=</span> <span class="n">columns</span> <span class="o">||</span> <span class="n">visited</span><span class="o">[</span><span class="n">nextRow</span><span class="o">][</span><span class="n">nextColumn</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// 顺时针转向 90°
</span><span class="c1"></span>                <span class="n">directionIndex</span> <span class="o">=</span> <span class="o">(</span><span class="n">directionIndex</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">4</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 按照当前方向，走一步
</span><span class="c1"></span>            <span class="n">row</span> <span class="o">+=</span> <span class="n">directions</span><span class="o">[</span><span class="n">directionIndex</span><span class="o">][</span><span class="n">0</span><span class="o">];</span>
            <span class="n">column</span> <span class="o">+=</span> <span class="n">directions</span><span class="o">[</span><span class="n">directionIndex</span><span class="o">][</span><span class="n">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shun-shi-zhen-da-yin-ju-zhen-by-leetcode-solution/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shun-shi-zhen-da-yin-ju-zhen-by-leetcode-solution/</a></p>
<p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/</a></p>
]]></description>
</item><item>
    <title>9、剑指 Offer 06. 从尾到头打印链表</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/9.html</link>
    <pubDate>Thu, 02 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/9.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 06. 从尾到头打印链表</a> 难度简单</p>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：head = [1,3,2]
输出：[2,3,1]
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= 链表长度 &lt;= 10000
</code></pre><h1 id="二解法">二、解法</h1>
<h2 id="21辅助栈">2.1、辅助栈</h2>
<h3 id="核心思想">核心思想：</h3>
<p>栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点的值压入栈内，然后依次弹出栈内的元素并存储到数组中。</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<p><strong>时间复杂度</strong>：O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。</p>
<p><strong>空间复杂度</strong>：O(n)。额外使用一个栈存储链表中的每个节点。</p>
<h3 id="代码">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">reversePrint</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// 遍历链表, 入栈
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>

        <span class="c1">// 循环出栈,构造数据
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="21递归法">2.1、递归法</h2>
<h3 id="核心思想-1">核心思想：</h3>
<p>利用递归： 先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。</p>
<ul>
<li><strong>递推阶段：</strong> 每次传入 <code>head.next</code> ，以 <code>head == null</code>（即走过链表尾部节点）为递归终止条件，此时直接返回。</li>
<li><strong>回溯阶段：</strong> 层层回溯时，将当前节点值加入列表，即<code>tmp.add(head.val)</code>。</li>
<li>最终，将列表 <code>tmp</code> 转化为数组 <code>res</code> ，并返回即可。</li>
</ul>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<p><strong>时间复杂度</strong>：O(N)，遍历链表，递归 N 次。</p>
<p><strong>空间复杂度</strong>：O(N)， 系统递归需要使用 O(N) 的栈空间。</p>
<h3 id="代码-1">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">arrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">reversePrint</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 边界值
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
        <span class="o">}</span>

        <span class="n">reverse</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">arrayList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arrayList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arrayList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 在递归遍历链表的回溯过程中利用 ArrayList 记录数据, 天然就是逆序的
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 递归调用
</span><span class="c1"></span>        <span class="n">reverse</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>

        <span class="c1">// 回溯阶段
</span><span class="c1"></span>        <span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/mian-shi-ti-06-cong-wei-dao-tou-da-yin-lian-biao-b/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/mian-shi-ti-06-cong-wei-dao-tou-da-yin-lian-biao-b/</a></p>
]]></description>
</item><item>
    <title>8、剑指 Offer 07. 重建二叉树</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/8.html</link>
    <pubDate>Tue, 31 Aug 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/8.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 07. 重建二叉树</a> 难度中等</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>示例 1:</strong></p>
<p></p>
<pre tabindex="0"><code>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
</code></pre><p><strong>示例 2:</strong></p>
<pre tabindex="0"><code>Input: preorder = [-1], inorder = [-1]
Output: [-1]
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= 节点个数 &lt;= 5000
</code></pre><p><strong>注意</strong>：本题与主站 105 题重复：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21递归法">2.1、递归法</h2>
<h3 id="核心思想">核心思想：</h3>
<p>对于任意一颗树而言，前序遍历的形式总是如下所示，且根节点总是前序遍历中的第一个节点。</p>
<pre tabindex="0"><code>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
</code></pre><p>而中序遍历的形式总是</p>
<pre tabindex="0"><code>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]
</code></pre><p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p>
<p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p>
<p><strong>细节</strong></p>
<p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<p><strong>时间复杂度</strong>：O(n)，其中 n 是树中的节点个数。</p>
<p><strong>空间复杂度</strong>：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h &lt; n，所以总空间复杂度为 O(n)。</p>
<h3 id="代码">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">// 前序遍历值
</span><span class="c1"></span>    <span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 中序遍历值
</span><span class="c1"></span>    <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="c1">// 保存中序遍历中每个元素各自出现的下标，方便定位
</span><span class="c1"></span>    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 初始化参数
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">preorder</span> <span class="o">=</span> <span class="n">preorder</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">inorder</span> <span class="o">=</span> <span class="n">inorder</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">inorder</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 递归调用
</span><span class="c1"></span>        <span class="n">TreeNode</span> <span class="n">result</span> <span class="o">=</span> <span class="n">myBuildTree</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 给定一个树的前序遍历与中序遍历，递归生成树结构
</span><span class="cm">     *
</span><span class="cm">     * @param preorderStartIndex 前序遍历下标区间 start
</span><span class="cm">     * @param preorderEndIndex   前序遍历下标区间 end
</span><span class="cm">     * @param inorderStartIndex  中序遍历下标区间 start
</span><span class="cm">     * @param inorderEndIndex    中序遍历下标区间 end
</span><span class="cm">     * @return 
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">myBuildTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">preorderStartIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">preorderEndIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">inorderStartIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">inorderEndIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">preorderStartIndex</span> <span class="o">&gt;</span> <span class="n">preorderEndIndex</span> <span class="o">||</span> <span class="n">inorderStartIndex</span> <span class="o">&gt;</span> <span class="n">inorderEndIndex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果下标超限,则说明该节点为 null
</span><span class="c1"></span>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 先取得根节点的值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootVal</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">preorder</span><span class="o">[</span><span class="n">preorderStartIndex</span><span class="o">];</span>

        <span class="c1">// 构造出一个新节点
</span><span class="c1"></span>        <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">rootVal</span><span class="o">);</span>

        <span class="c1">// 获取根节点的值处于中序遍历中的下标
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootIndex</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">rootVal</span><span class="o">);</span>

        <span class="c1">// 计算左子树元素的个数
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">leftSubtreeSize</span> <span class="o">=</span> <span class="n">rootIndex</span> <span class="o">-</span> <span class="n">inorderStartIndex</span><span class="o">;</span>

        <span class="c1">// 递归处理左子树
</span><span class="c1"></span>        <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">myBuildTree</span><span class="o">(</span><span class="n">preorderStartIndex</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">preorderStartIndex</span> <span class="o">+</span> <span class="n">leftSubtreeSize</span><span class="o">,</span> <span class="n">inorderStartIndex</span><span class="o">,</span> <span class="n">rootIndex</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>

        <span class="c1">// 递归处理右子树
</span><span class="c1"></span>        <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">myBuildTree</span><span class="o">(</span><span class="n">preorderStartIndex</span> <span class="o">+</span> <span class="n">1</span> <span class="o">+</span> <span class="n">leftSubtreeSize</span><span class="o">,</span> <span class="n">preorderEndIndex</span><span class="o">,</span> <span class="n">rootIndex</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">inorderEndIndex</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22迭代法未完待续">2.2、迭代法（未完待续）</h2>
<h3 id="核心思想-1">核心思想：</h3>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<h3 id="代码-1">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 迭代法
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">preorder</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 初始化根节点
</span><span class="c1"></span>        <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">0</span><span class="o">]);</span>

        <span class="n">Deque</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">inorderIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">preorderVal</span> <span class="o">=</span> <span class="n">preorder</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>

            <span class="c1">// 用前序数组一直构建左子树
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">inorder</span><span class="o">[</span><span class="n">inorderIndex</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">preorderVal</span><span class="o">);</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 碰到了inorder[inorderIndex]，表示到了左下角，这时就需要往上走并处理右子树
</span><span class="c1"></span>                <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">val</span> <span class="o">==</span> <span class="n">inorder</span><span class="o">[</span><span class="n">inorderIndex</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                    <span class="n">inorderIndex</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">preorderVal</span><span class="o">);</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</a></p>
]]></description>
</item></channel>
</rss>
