<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>無糖的小宇宙</title>
        <link>https://sugarless.cn/</link>
        <description>無糖的博客，一个知识网络沉淀，日常生活观察者的小宇宙。</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>jaded@foxmail.com (無糖)</managingEditor>
            <webMaster>jaded@foxmail.com (無糖)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 10 Oct 2021 00:00:00 &#43;0000</lastBuildDate>
            <atom:link href="https://sugarless.cn/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>[ 置顶 ] 🚩 Github 项目 / 工具站点 / 有趣的站点</title>
    <link>https://sugarless.cn/posts/mark/1.html</link>
    <pubDate>Tue, 31 Dec 2019 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/mark/1.html</guid>
    <description><![CDATA[<p>内容不定期持续更新，感谢每一位开源项目作者为全世界开发者做出的杰出贡献。本文主要分享一些我平时收集到的一些好物，东西可能比较杂乱。涵盖开源项目、免费的工具站、好用的客户端工具、优秀的付费网站和来路不明的沙雕网站。</p>
<h1 id="github-开源项目">Github 开源项目</h1>
<h2 id="功能性网站">功能性网站</h2>
<h3 id="1兰空图床">1、兰空图床</h3>
<p>使用 thinkphp + mysql 开发，界面简洁易用，支持第三方云储存和远程 FTP 存储。并且有开源的浏览器插件支持。（真香）</p>
<p>官网：<a href="https://www.lsky.pro" target="_blank" rel="noopener noreffer">https://www.lsky.pro</a></p>
<p>GitHub：<a href="https://github.com/wisp-x/lsky-pro" target="_blank" rel="noopener noreffer">https://github.com/wisp-x/lsky-pro</a></p>
<p>浏览器扩展：<a href="https://github.com/wisp-x/lsky-pro-chrome-extension" target="_blank" rel="noopener noreffer">https://github.com/wisp-x/lsky-pro-chrome-extension</a></p>
<h3 id="2基于-phphtml-的轻量级网络测试站点">2、基于 php+html 的轻量级网络测试站点</h3>
<p>HTML5 Speedtest 可用于查看下载速度、ping 速度、上传速度；很小巧方便，直接打开页面点击一下 start 就能自动检测，你本机到远程服务器的网络状况，快速得到观测数据</p>
<p>Github：<a href="https://github.com/librespeed/speedtest" target="_blank" rel="noopener noreffer">https://github.com/librespeed/speedtest</a></p>
<h3 id="3flarum-论坛">3、flarum 论坛</h3>
<p>基于 PHP Laravel 框架构建的一款优雅简洁论坛软件。发帖及跟帖回复使用 markdown 语法是一个亮点。</p>
<p>官网：<a href="https://flarum.org" target="_blank" rel="noopener noreffer">https://flarum.org</a></p>
<p>中文官网：<a href="https://flarum.org.cn" target="_blank" rel="noopener noreffer">https://flarum.org.cn</a></p>
<p>Github：<a href="https://github.com/flarum/flarum" target="_blank" rel="noopener noreffer">https://github.com/flarum/flarum</a></p>
<h2 id="命令行工具">命令行工具</h2>
<h3 id="1annie">1、annie</h3>
<p>基于 Go 开发的一款命令行视频下载器，支持的平台很多，包括 MacOS、Windows、Linux 等。目前支持 bilibili 和 youtube 的播放列表批量下载，其他网站只支持单个视频下载。</p>
<p>Github：<a href="https://github.com/iawia002/annie" target="_blank" rel="noopener noreffer">https://github.com/iawia002/annie</a></p>
<h3 id="2youtube-dl">2、youtube-dl</h3>
<p>下载 youtube 视频的神器
Github：<a href="https://github.com/ytdl-org/youtube-dl" target="_blank" rel="noopener noreffer">https://github.com/ytdl-org/youtube-dl</a>
官网：<a href="http://ytdl-org.github.io/youtube-dl/" target="_blank" rel="noopener noreffer">http://ytdl-org.github.io/youtube-dl/</a></p>
<h2 id="开发工具">开发工具</h2>
<h3 id="1anotherredisdesktopmanager">1、AnotherRedisDesktopManager</h3>
<p>一个 GUI Redis 桌面管理器，兼容 Linux、Windows、Mac。更重要的是，在加载大量的键时，它不会崩溃。</p>
<p>Github：<a href="https://github.com/qishibo/AnotherRedisDesktopManager" target="_blank" rel="noopener noreffer">https://github.com/qishibo/AnotherRedisDesktopManager</a></p>
<h3 id="2switchhosts">2、SwitchHosts</h3>
<p>SwitchHosts 是一个管理、切换多个 hosts 方案的工具。</p>
<p>Github：<a href="https://github.com/oldj/SwitchHosts" target="_blank" rel="noopener noreffer">https://github.com/oldj/SwitchHosts</a></p>
<p>官网：<a href="https://swh.app/zh/" target="_blank" rel="noopener noreffer">https://swh.app/zh/</a></p>
<h3 id="3docsify">3、docsify</h3>
<p>docsify 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 index.html 就可以开始编写文档并直接部署在 GitHub Pages。</p>
<p>Github：<a href="https://github.com/docsifyjs/docsify/" target="_blank" rel="noopener noreffer">https://github.com/docsifyjs/docsify/</a></p>
<p>官网：<a href="https://docsify.js.org/" target="_blank" rel="noopener noreffer">https://docsify.js.org/</a></p>
<h2 id="ui-框架">UI 框架</h2>
<h3 id="1layui">1、LayUI</h3>
<p>对非专业前端的开发人员非常友好，组件丰富，极低门槛，开箱即用。</p>
<p>官网：<a href="https://www.layui.com" target="_blank" rel="noopener noreffer">https://www.layui.com</a></p>
<p>GitHub：<a href="https://github.com/sentsin/layui" target="_blank" rel="noopener noreffer">https://github.com/sentsin/layui</a></p>
<h3 id="2vant-weapp">2、vant-weapp</h3>
<p>有赞出品的开源小程序 UI 组件库</p>
<p>官网：<a href="https://youzan.github.io/vant-weapp" target="_blank" rel="noopener noreffer">https://youzan.github.io/vant-weapp</a></p>
<p>GitHub：<a href="https://github.com/youzan/vant-weapp" target="_blank" rel="noopener noreffer">https://github.com/youzan/vant-weapp</a></p>
<h3 id="3elementui">3、ElementUI</h3>
<p>饿了么开发的基于 Vue 2.0 的桌面端组件库</p>
<p>官网：<a href="https://element.eleme.cn" target="_blank" rel="noopener noreffer">https://element.eleme.cn</a></p>
<h2 id="wordpress-主题">WordPress 主题</h2>
<h3 id="1argon-theme">1、argon-theme</h3>
<p>博客、文章向主题</p>
<p>Github：<a href="https://github.com/solstice23/argon-theme" target="_blank" rel="noopener noreffer">https://github.com/solstice23/argon-theme</a></p>
<p>Demo：<a href="https://solstice23.top/archives/746" target="_blank" rel="noopener noreffer">https://solstice23.top/archives/746</a></p>
<h3 id="2puock">2、Puock</h3>
<p>博客、文章主题</p>
<p>Github：<a href="https://github.com/Licoy/wordpress-theme-puock" target="_blank" rel="noopener noreffer">https://github.com/Licoy/wordpress-theme-puock</a></p>
<p>Demo：<a href="https://www.licoy.cn" target="_blank" rel="noopener noreffer">https://www.licoy.cn</a></p>
<h3 id="3webstack">3、WebStack</h3>
<p>网址导航主题</p>
<p>Github：<a href="https://github.com/owen0o0/WebStack" target="_blank" rel="noopener noreffer">https://github.com/owen0o0/WebStack</a></p>
<h2 id="hugo-主题">Hugo 主题</h2>
<h3 id="1doit">1、DoIt</h3>
<p>个人博客主题</p>
<p>Github：<a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer">https://github.com/HEIGE-PCloud/DoIt</a></p>
<p>Demo：<a href="https://hugodoit.pages.dev/zh-cn/" target="_blank" rel="noopener noreffer">https://hugodoit.pages.dev/zh-cn/</a></p>
<h3 id="2hugo-theme-meme">2、hugo-theme-meme</h3>
<p>个人博客主题</p>
<p>Github：<a href="https://github.com/reuixiy/hugo-theme-meme" target="_blank" rel="noopener noreffer">https://github.com/reuixiy/hugo-theme-meme</a></p>
<p>Demo：<a href="https://io-oi.me/" target="_blank" rel="noopener noreffer">https://io-oi.me/</a></p>
<h2 id="javascript">JavaScript</h2>
<h3 id="1introjs">1、intro.js</h3>
<p>网站页面 / 新功能 引导流程插件</p>
<p>官网：<a href="http://introjs.com" target="_blank" rel="noopener noreffer">http://introjs.com</a></p>
<p>GitHub：<a href="https://github.com/usablica/intro.js" target="_blank" rel="noopener noreffer">https://github.com/usablica/intro.js</a></p>
<h3 id="2clipboardjs">2、clipboard.js</h3>
<p>js 实现一键复制文本到剪贴板插件</p>
<p>官网：<a href="https://clipboardjs.com" target="_blank" rel="noopener noreffer">https://clipboardjs.com</a></p>
<p>GitHub：<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener noreffer">https://github.com/zenorocha/clipboard.js</a></p>
<h3 id="3viewerjs">3、viewer.js</h3>
<p>js 图片浏览插件</p>
<p>官网：<a href="https://fengyuanchen.github.io/viewerjs" target="_blank" rel="noopener noreffer">https://fengyuanchen.github.io/viewerjs</a></p>
<p>Github：<a href="https://github.com/fengyuanchen/viewerjs" target="_blank" rel="noopener noreffer">https://github.com/fengyuanchen/viewerjs</a></p>
<h3 id="4contextjs">4、context.js</h3>
<p>右键菜单插件</p>
<p>官网：<a href="http://lab.jakiestfu.com/contextjs" target="_blank" rel="noopener noreffer">http://lab.jakiestfu.com/contextjs</a></p>
<p>Github：<a href="https://github.com/jakiestfu/Context.js" target="_blank" rel="noopener noreffer">https://github.com/jakiestfu/Context.js</a></p>
<h3 id="5momentjs">5、moment.js</h3>
<p>JavaScript 日期处理类库，多语言支持</p>
<p>官网：<a href="https://momentjs.com" target="_blank" rel="noopener noreffer">https://momentjs.com</a> / <a href="http://momentjs.cn" target="_blank" rel="noopener noreffer">http://momentjs.cn</a></p>
<h3 id="6highlightjs">6、highlight.js</h3>
<p>代码高亮 / 支持 189 种编程语言 / 95 种高亮样式</p>
<p>Github：<a href="https://github.com/highlightjs/highlight.js" target="_blank" rel="noopener noreffer">https://github.com/highlightjs/highlight.js</a></p>
<p>官网：<a href="https://highlightjs.org" target="_blank" rel="noopener noreffer">https://highlightjs.org</a> / <a href="https://highlightjs.org/static/demo" target="_blank" rel="noopener noreffer">https://highlightjs.org/static/demo</a></p>
<h3 id="7pangujs">7、Pangu.js</h3>
<p>中文字和英文、数字、符号之间自动插入空格</p>
<p>Github：<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener noreffer">https://github.com/vinta/pangu.js</a></p>
<p>官网：暂无</p>
<h2 id="m3u-直播源">M3U 直播源</h2>
<h3 id="1wtv">1、wtv</h3>
<p>解决电脑、手机看电视直播的苦恼，收集各种直播源，电视直播网站。建议配合 potplayer 使用。</p>
<p>Github：<a href="https://github.com/biancangming/wtv" target="_blank" rel="noopener noreffer">https://github.com/biancangming/wtv</a></p>
<h2 id="客户端软件">客户端软件</h2>
<h3 id="1contextmenumanager">1、ContextMenuManager</h3>
<p>一个纯粹的 Windows 右键菜单管理程序</p>
<p>Github：<a href="https://github.com/BluePointLilac/ContextMenuManager" target="_blank" rel="noopener noreffer">https://github.com/BluePointLilac/ContextMenuManager</a></p>
<p>官网：<a href="https://bluepointlilac.github.io/ContextMenuManager" target="_blank" rel="noopener noreffer">https://bluepointlilac.github.io/ContextMenuManager</a></p>
<h1 id="工具站点">工具站点</h1>
<h2 id="开发">开发</h2>
<h3 id="1requestcatchercom">1、requestcatcher.com</h3>
<p>Debug web hooks, http clients, etc.</p>
<p>Request Catcher will create a subdomain on which you can test an application. All requests sent to any path on the subdomain are forwarded to your browser in real time.</p>
<p>官网：<a href="https://requestcatcher.com" target="_blank" rel="noopener noreffer">https://requestcatcher.com</a></p>
<h3 id="2jsoncn">2、json.cn</h3>
<p>json 格式化</p>
<p>官网：<a href="http://json.cn" target="_blank" rel="noopener noreffer">http://json.cn</a></p>
<h3 id="3searchcode">3、searchcode</h3>
<p>是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。</p>
<p>官网：<a href="https://searchcode.com" target="_blank" rel="noopener noreffer">https://searchcode.com</a></p>
<p>设计
1、创客贴
付费网站，但提供一些免费资源，比较灵活的在线设计工具。风格比较偏向 MG 动画，可以搞出很花哨的 banner 和长图海报之类的，算是个不错的设计资源网站。</p>
<p>官网：<a href="https://www.chuangkit.com" target="_blank" rel="noopener noreffer">https://www.chuangkit.com</a></p>
<h2 id="书籍">书籍</h2>
<h3 id="1鸠摩搜索">1、鸠摩搜索</h3>
<p>鸠摩是一个电子书搜索引擎，界面简洁、内容纯净，专业而高效。</p>
<p>官网：<a href="https://www.jiumodiary.com" target="_blank" rel="noopener noreffer">https://www.jiumodiary.com</a></p>
<h3 id="2thefuture-书籍搜索">2、thefuture 书籍搜索</h3>
<p>小站，知名度不高，但试着搜索了几本书，感觉还挺好用。</p>
<p>官网：<a href="https://bks.thefuture.top" target="_blank" rel="noopener noreffer">https://bks.thefuture.top</a></p>
<h3 id="3z-library">3、z-library</h3>
<p>可以找到不少英文原版书籍</p>
<p>官网：<a href="https://zh.z-lib.org/" target="_blank" rel="noopener noreffer">https://zh.z-lib.org/</a></p>
<h3 id="4全国图书馆参考咨询联盟">4、全国图书馆参考咨询联盟</h3>
<p>由中国公共、教育、科技系统 图书馆合作建立的公益性服务机构，能找到不少书籍，但下载比较麻烦。</p>
<p>官网：<a href="http://www.ucdrs.superlib.net/" target="_blank" rel="noopener noreffer">http://www.ucdrs.superlib.net/</a></p>
<h2 id="生产力">生产力</h2>
<h3 id="1gitmind-在线思维导图">1、GitMind 在线思维导图</h3>
<p><a href="https://gitmind.cn" target="_blank" rel="noopener noreffer">https://gitmind.cn</a></p>
<h2 id="图像">图像</h2>
<h3 id="1ai-人工智能图片无损放大">1、AI 人工智能图片无损放大</h3>
<p><a href="https://bigjpg.com" target="_blank" rel="noopener noreffer">https://bigjpg.com</a></p>
<h3 id="2tinypng-图片在线压缩">2、tinypng 图片在线压缩</h3>
<p><a href="https://tinypng.com/" target="_blank" rel="noopener noreffer">https://tinypng.com/</a></p>
<h3 id="3squoosh谷歌图片在线压缩--开源">3、Squoosh（谷歌图片在线压缩 / 开源）</h3>
<p><a href="https://squoosh.app/" target="_blank" rel="noopener noreffer">https://squoosh.app/</a></p>
<h3 id="4消除图片中的背景--ai-自动抠图">4、消除图片中的背景 / AI 自动抠图</h3>
<p><a href="https://www.remove.bg/zh" target="_blank" rel="noopener noreffer">https://www.remove.bg/zh</a></p>
<h3 id="5中国哲学书电子化计划">5、中国哲学书电子化计划</h3>
<p>中国哲学书电子化计划是一个线上开放电子图书馆，为中外学者提供中国历代传世文献，力图超越印刷媒体限制，通过电子科技探索新方式与古代文献进行沟通。收藏的文本已超过三万部著作，并有五十亿字之多，故为历代中文文献资料库最大者。</p>
<p><a href="https://ctext.org/zhs" target="_blank" rel="noopener noreffer">https://ctext.org/zhs</a></p>
<h2 id="内容创作">内容创作</h2>
<h3 id="1emoji大全--emoji表情符号词典-">1、Emoji大全 | Emoji表情符号词典 📓</h3>
<p><a href="https://www.emojiall.com/zh-hans" target="_blank" rel="noopener noreffer">https://www.emojiall.com/zh-hans</a></p>
<h3 id="2deepl-翻译">2、DeepL 翻译</h3>
<p><a href="https://www.deepl.com/translator" target="_blank" rel="noopener noreffer">https://www.deepl.com/translator</a></p>
<h2 id="kms">KMS</h2>
<h3 id="1沧水-kms">1、沧水 KMS</h3>
<p><a href="https://kms.cangshui.net" target="_blank" rel="noopener noreffer">https://kms.cangshui.net</a></p>
<h3 id="2moerats-kms">2、moerats KMS</h3>
<p><a href="https://www.moerats.com/kms" target="_blank" rel="noopener noreffer">https://www.moerats.com/kms</a></p>
<h2 id="其他">其他</h2>
<h3 id="1台风路径查询">1、台风路径查询</h3>
<p><a href="http://typhoon.zjwater.gov.cn" target="_blank" rel="noopener noreffer">http://typhoon.zjwater.gov.cn</a></p>
<h3 id="2黑客模拟器">2、黑客模拟器</h3>
<p><a href="http://geektyper.com" target="_blank" rel="noopener noreffer">http://geektyper.com</a></p>
<h3 id="3世界护照大全">3、世界护照大全</h3>
<p><a href="https://www.passportindex.org/cn" target="_blank" rel="noopener noreffer">https://www.passportindex.org/cn</a></p>
<h3 id="4查无此人--ai-生成人脸">4、查无此人 / AI 生成人脸</h3>
<p><a href="https://thispersondoesnotexist.com" target="_blank" rel="noopener noreffer">https://thispersondoesnotexist.com</a></p>
<h3 id="5网页版-windows93">5、网页版 windows93</h3>
<p><a href="http://www.windows93.net" target="_blank" rel="noopener noreffer">http://www.windows93.net</a></p>
<h3 id="6假装系统在升级">6、假装系统在升级</h3>
<p><a href="http://fakeupdate.net" target="_blank" rel="noopener noreffer">http://fakeupdate.net</a></p>
<h2 id="好像有那么点用">好像有那么点用</h2>
<h3 id="1全历史">1、全历史</h3>
<p><a href="https://www.allhistory.com" target="_blank" rel="noopener noreffer">https://www.allhistory.com</a></p>
<h3 id="2西窗烛--古诗">2、西窗烛 / 古诗</h3>
<p><a href="http://lib.xcz.im/library" target="_blank" rel="noopener noreffer">http://lib.xcz.im/library</a></p>]]></description>
</item><item>
    <title>Mathpix Snip - Convert images to LaTeX</title>
    <link>https://sugarless.cn/posts/mathpix.html</link>
    <pubDate>Sun, 10 Oct 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/mathpix.html</guid>
    <description><![CDATA[<p>在编写论文 、博客等内容时，想要输入数学公式就比较麻烦了。如果你使用 Mathpix Snip，<strong>只需要截个图，Mathpix Snip就可以将截图中的公式自动转化为 LaTex 代码表达式</strong>，我们只需要简单地修改修改就可以直接插入到<strong>LaTex或Word中</strong>，公式较为清晰规范的话是不需要修改的。<strong>而且可以识别手写的公式</strong>。</p>
<p>官网：<a href="https://mathpix.com/" target="_blank" rel="noopener noreffer">https://mathpix.com/</a></p>
<p>下载：<a href="https://mathpix.com/#downloads" target="_blank" rel="noopener noreffer">https://mathpix.com/#downloads</a></p>
<p>如果使用 edu 教育邮箱注册 mathpix 账户，每天有 100 次的免费额度。</p>
<!-- raw HTML omitted -->
<a class="lightgallery" href="/post_images/image-20211010201350465.png" title="/post_images/image-20211010201350465.png" data-thumbnail="/post_images/image-20211010201350465.png">
        
    </a>]]></description>
</item><item>
    <title>29、剑指 Offer 20. 表示数值的字符串</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/29.html</link>
    <pubDate>Sun, 03 Oct 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/29.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<h4 id="剑指-offer-20-表示数值的字符串httpsleetcode-cncomproblemsbiao-shi-shu-zhi-de-zi-fu-chuan-lcof-难度中等"><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 20. 表示数值的字符串</a> 难度中等</h4>
<p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p>
<p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>若干空格</li>
<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>
<li>（可选）一个 <code>'e'</code> 或 <code>'E'</code> ，后面跟着一个 <strong>整数</strong></li>
<li>若干空格</li>
</ol>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>
<li>下述格式之一：
<ol>
<li>至少一位数字，后面跟着一个点 <code>'.'</code></li>
<li>至少一位数字，后面跟着一个点 <code>'.'</code> ，后面再跟着至少一位数字</li>
<li>一个点 <code>'.'</code> ，后面跟着至少一位数字</li>
</ol>
</li>
</ol>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>
<li>至少一位数字</li>
</ol>
<p>部分<strong>数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li>
</ul>
<p>部分<strong>非数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;0&quot;
输出：true
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;e&quot;
输出：false
</code></pre><p><strong>示例 3：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;.&quot;
输出：false
</code></pre><p><strong>示例 4：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;    .1  &quot;
输出：true
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>'+'</code> ，减号 <code>'-'</code> ，空格 <code>' '</code> 或者点 <code>'.'</code> 。</li>
</ul>
<h1 id="二解法">二、解法</h1>
<h2 id="21确定有限状态自动机官方题解">2.1、确定有限状态自动机（官方题解）</h2>
<h3 id="核心思路">核心思路</h3>
<p><strong>预备知识</strong></p>
<p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：</p>
<p>有一个特殊的状态，被称作「初始状态」。
还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。
起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。</p>
<p>注意：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。</p>
<p>一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。</p>
<p>自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。</p>
<p>自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。</p>
<p><strong>问题描述</strong></p>
<p>在 <a href="https://en.cppreference.com/w/cpp/language/floating_literal" target="_blank" rel="noopener noreffer">C++ 文档</a> 中，描述了一个合法的数值字符串应当具有的格式。具体而言，它包含以下部分：</p>
<p>符号位，即 ++、-− 两种符号
整数部分，即由若干字符 0-90−9 组成的字符串
小数点
小数部分，其构成与整数部分相同
指数部分，其中包含开头的字符 \text{e}e（大写小写均可）、可选的符号位，和整数部分
相比于 C++ 文档而言，本题还有一点额外的不同，即允许字符串首末两端有一些额外的空格。</p>
<p>在上面描述的五个部分中，每个部分都不是必需的，但也受一些额外规则的制约，如：</p>
<p>如果符号位存在，其后面必须跟着数字或小数点。
小数点的前后两侧，至少有一侧是数字。</p>
<p><strong>思路与算法</strong></p>
<p>根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：</p>
<p>起始的空格
符号位
整数部分
左侧有整数的小数点
左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）
小数部分
字符 e
指数部分的符号位
指数部分的整数部分
末尾的空格
下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 1，而「接受状态」的集合则为状态 3、状态 4、状态 6、状态 9 以及状态 10。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。</p>
<p>最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来：</p>
<a class="lightgallery" href="/post_images/image-20210913110127164.png" title="/post_images/image-20210913110127164.png" data-thumbnail="/post_images/image-20210913110127164.png">
        
    </a>
<!-- raw HTML omitted -->
<p>比较上图与「预备知识」一节中对自动机的描述，可以看出有一点不同：</p>
<p>我们没有单独地考虑每种字符，而是划分为若干类。由于全部 10 个数字字符彼此之间都等价，因此只需定义一种统一的「数字」类型即可。对于正负号也是同理。
在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n)，其中 n 为字符串的长度。我们需要遍历字符串的每个字符，其中状态转移所需的时间复杂度为 O(1)。</p>
<p><strong>空间复杂度</strong>：O(1)，只需要创建固定大小的状态转移表。</p>
<h3 id="code">Code：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">// 有限状态集合
</span><span class="c1"></span>    <span class="kd">enum</span> <span class="n">State</span> <span class="o">{</span>
        <span class="c1">// 起始的空格
</span><span class="c1"></span>        <span class="n">STATE_INITIAL</span><span class="o">,</span>
        <span class="c1">// 整数部分符号位
</span><span class="c1"></span>        <span class="n">STATE_INT_SIGN</span><span class="o">,</span>
        <span class="c1">// 整数部分
</span><span class="c1"></span>        <span class="n">STATE_INTEGER</span><span class="o">,</span>
        <span class="c1">// 左侧有整数的小数点
</span><span class="c1"></span>        <span class="n">STATE_POINT</span><span class="o">,</span>
        <span class="c1">// 左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）
</span><span class="c1"></span>        <span class="n">STATE_POINT_WITHOUT_INT</span><span class="o">,</span>
        <span class="c1">// 小数部分
</span><span class="c1"></span>        <span class="n">STATE_FRACTION</span><span class="o">,</span>
        <span class="c1">// 字符 e
</span><span class="c1"></span>        <span class="n">STATE_EXP</span><span class="o">,</span>
        <span class="c1">// 指数部分的符号位
</span><span class="c1"></span>        <span class="n">STATE_EXP_SIGN</span><span class="o">,</span>
        <span class="c1">// 指数部分的整数部分
</span><span class="c1"></span>        <span class="n">STATE_EXP_NUMBER</span><span class="o">,</span>
        <span class="c1">// 末尾的空格
</span><span class="c1"></span>        <span class="n">STATE_END</span>
    <span class="o">}</span>

    <span class="c1">// 字符类型集合
</span><span class="c1"></span>    <span class="kd">enum</span> <span class="n">CharType</span> <span class="o">{</span>
        <span class="c1">// 数字
</span><span class="c1"></span>        <span class="n">CHAR_NUMBER</span><span class="o">,</span>
        <span class="c1">// 字符 e
</span><span class="c1"></span>        <span class="n">CHAR_EXP</span><span class="o">,</span>
        <span class="c1">// 小数点
</span><span class="c1"></span>        <span class="n">CHAR_POINT</span><span class="o">,</span>
        <span class="c1">// 正负号
</span><span class="c1"></span>        <span class="n">CHAR_SIGN</span><span class="o">,</span>
        <span class="c1">// 空格
</span><span class="c1"></span>        <span class="n">CHAR_SPACE</span><span class="o">,</span>
        <span class="c1">// 非法字符
</span><span class="c1"></span>        <span class="n">CHAR_ILLEGAL</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 状态机
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">State</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;&gt;</span> <span class="n">transfer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">State</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;&gt;();</span>


        <span class="c1">// 空格（初始状态） 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">initialMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="c1">// 空格
</span><span class="c1"></span>            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INITIAL</span><span class="o">);</span>
            <span class="c1">// 整数
</span><span class="c1"></span>            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span><span class="o">);</span>
            <span class="c1">// 小数点
</span><span class="c1"></span>            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_POINT</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT_WITHOUT_INT</span><span class="o">);</span>
            <span class="c1">// 正负号
</span><span class="c1"></span>            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SIGN</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INT_SIGN</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_INITIAL</span><span class="o">,</span> <span class="n">initialMap</span><span class="o">);</span>


        <span class="c1">// 整数部分符号位 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">intSignMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_POINT</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT_WITHOUT_INT</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_INT_SIGN</span><span class="o">,</span> <span class="n">intSignMap</span><span class="o">);</span>


        <span class="c1">// 整数部分 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">integerMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_EXP</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_POINT</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span><span class="o">,</span> <span class="n">integerMap</span><span class="o">);</span>

        <span class="c1">// 左侧有整数的小数点 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">pointMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_EXP</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT</span><span class="o">,</span> <span class="n">pointMap</span><span class="o">);</span>

        <span class="c1">// 左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分) 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">pointWithoutIntMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT_WITHOUT_INT</span><span class="o">,</span> <span class="n">pointWithoutIntMap</span><span class="o">);</span>

        <span class="c1">// 小数部分
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">fractionMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_EXP</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span><span class="o">,</span> <span class="n">fractionMap</span><span class="o">);</span>

        <span class="c1">// 字符 e 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">expMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SIGN</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_SIGN</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP</span><span class="o">,</span> <span class="n">expMap</span><span class="o">);</span>

        <span class="c1">// 指数部分的符号位 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">expSignMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_SIGN</span><span class="o">,</span> <span class="n">expSignMap</span><span class="o">);</span>

        <span class="c1">// 指数部分的整数部分 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">expNumberMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span><span class="o">);</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span><span class="o">,</span> <span class="n">expNumberMap</span><span class="o">);</span>

        <span class="c1">// 末尾的空格 的所有可转移状态
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;</span> <span class="n">endMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">CharType</span><span class="o">,</span> <span class="n">State</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">,</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">);</span>
        <span class="o">}};</span>
        <span class="n">transfer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">,</span> <span class="n">endMap</span><span class="o">);</span>


        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// 初始状态
</span><span class="c1"></span>        <span class="n">State</span> <span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INITIAL</span><span class="o">;</span>

        <span class="c1">// 循环处理每个字符, 模拟状态转移
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 获取当前字符的类型
</span><span class="c1"></span>            <span class="n">CharType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">toCharType</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>

            <span class="k">if</span> <span class="o">(!</span><span class="n">transfer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">state</span><span class="o">).</span><span class="na">containsKey</span><span class="o">(</span><span class="n">type</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">transfer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">state</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">type</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_INTEGER</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_POINT</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_FRACTION</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_EXP_NUMBER</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">STATE_END</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 获取字符的类型
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">CharType</span> <span class="nf">toCharType</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_NUMBER</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;e&#39;</span> <span class="o">||</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_EXP</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_POINT</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SIGN</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_SPACE</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">CharType</span><span class="o">.</span><span class="na">CHAR_ILLEGAL</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22确定有限状态自动机评论区">2.2、确定有限状态自动机（评论区）</h2>
<h3 id="核心思路-1">核心思路</h3>
<p>本题使用有限状态自动机。根据字符类型和合法数值的特点，先定义状态，再画出状态转移图，最后编写代码即可。</p>
<p><strong>字符类型</strong>：</p>
<p>空格 「 」、数字「 0—9 」 、正负号 「 +− 」 、小数点 「 . 」 、幂符号 「 eE 」 。</p>
<p><strong>状态定义</strong>：</p>
<p>按照字符串从左到右的顺序，定义以下 9 种状态。</p>
<ul>
<li>开始的空格</li>
<li>幂符号前的正负号</li>
<li>小数点前的数字</li>
<li>小数点、小数点后的数字</li>
<li>当小数点前为空格时，小数点、小数点后的数字</li>
<li>幂符号</li>
<li>幂符号后的正负号</li>
<li>幂符号后的数字</li>
<li>结尾的空格</li>
</ul>
<p><strong>结束状态</strong>：</p>
<p>合法的结束状态有 2, 3, 7, 8 。</p>
<a class="lightgallery" href="/post_images/image-20210913105508562.png" title="/post_images/image-20210913105508562.png" data-thumbnail="/post_images/image-20210913105508562.png">
        
    </a>
<!-- raw HTML omitted -->
<h3 id="复杂度分析-1">复杂度分析</h3>
<p><strong>时间复杂度</strong>：其中 N 为字符串 s 的长度，判断需遍历字符串，每轮状态转移的使用 O(1) 时间。</p>
<p><strong>空间复杂度</strong>：states 和 p 使用常数大小的额外空间。</p>
<h3 id="code-1">Code：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HashMap</span><span class="o">[]</span> <span class="n">states</span> <span class="o">=</span> <span class="o">{</span>
                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;s&#39;</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">2</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="n">4</span><span class="o">);</span> <span class="o">}},</span> <span class="c1">// 0. start with &#39;blank&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">2</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="n">4</span><span class="o">);</span> <span class="o">}},</span>                           <span class="c1">// 1. &#39;sign&#39; before &#39;e&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">2</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="n">3</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;e&#39;</span><span class="o">,</span> <span class="n">5</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">8</span><span class="o">);</span> <span class="o">}},</span> <span class="c1">// 2. &#39;digit&#39; before &#39;dot&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">3</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;e&#39;</span><span class="o">,</span> <span class="n">5</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">8</span><span class="o">);</span> <span class="o">}},</span>              <span class="c1">// 3. &#39;digit&#39; after &#39;dot&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">3</span><span class="o">);</span> <span class="o">}},</span>                                        <span class="c1">// 4. &#39;digit&#39; after &#39;dot&#39; (‘blank’ before &#39;dot&#39;)
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;s&#39;</span><span class="o">,</span> <span class="n">6</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">7</span><span class="o">);</span> <span class="o">}},</span>                           <span class="c1">// 5. &#39;e&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">7</span><span class="o">);</span> <span class="o">}},</span>                                        <span class="c1">// 6. &#39;sign&#39; after &#39;e&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="n">7</span><span class="o">);</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">8</span><span class="o">);</span> <span class="o">}},</span>                           <span class="c1">// 7. &#39;digit&#39; after &#39;e&#39;
</span><span class="c1"></span>                <span class="k">new</span> <span class="n">HashMap</span><span class="o">()</span> <span class="o">{{</span> <span class="n">put</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">8</span><span class="o">);</span> <span class="o">}}</span>                                         <span class="c1">// 8. end with &#39;blank&#39;
</span><span class="c1"></span>        <span class="o">};</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="sc">&#39;d&#39;</span><span class="o">;</span>       <span class="c1">// digit
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="sc">&#39;s&#39;</span><span class="o">;</span>  <span class="c1">// sign
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;e&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="sc">&#39;e&#39;</span><span class="o">;</span>  <span class="c1">// e or E
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span> <span class="n">t</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>    <span class="c1">// dot, blank
</span><span class="c1"></span>            <span class="k">else</span> <span class="n">t</span> <span class="o">=</span> <span class="sc">&#39;?&#39;</span><span class="o">;</span>                           <span class="c1">// unknown
</span><span class="c1"></span>            <span class="k">if</span><span class="o">(!</span><span class="n">states</span><span class="o">[</span><span class="n">p</span><span class="o">].</span><span class="na">containsKey</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">states</span><span class="o">[</span><span class="n">p</span><span class="o">].</span><span class="na">get</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">p</span> <span class="o">==</span> <span class="n">2</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">3</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">7</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">8</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="23常规解法">2.3、常规解法</h2>
<h3 id="核心思路-2">核心思路</h3>
<blockquote>
<p>什么有限状态自动机的我不太懂，常规解法可以做就不想搞这种可能只有这道题会用到的解法。</p>
</blockquote>
<p>我首先想到的是判断否 false 而不是判断是 true，毕竟有这么多条件满足才能判断 true，但是只要有一个条件不满足就可以判断 false，最后代码的效率也还可以，那么接下来进入正题吧：</p>
<ol>
<li>
<p>首先定义了四个flag，对应四种字符</p>
<ul>
<li>是否有数字：hasNum</li>
<li>是否有e：hasE</li>
<li>是否有正负符号：hasSign</li>
<li>是否有点：hasDot</li>
</ul>
</li>
<li>
<p>其余还定义了字符串长度 n 以及字符串索引 index</p>
</li>
<li>
<p>先处理一下开头的空格，index 相应的后移</p>
</li>
<li>
<p>然后进入循环，遍历字符串</p>
<ul>
<li>如果当前字符 c 是数字：将 hasNum 置为 true ，index 往后移动一直到非数字或遍历到末尾位置；如果已遍历到末尾 ( index == n ) ，结束循环</li>
<li>如果当前字符 c 是 &lsquo;e&rsquo; 或 &lsquo;E&rsquo; ：如果 e 已经出现或者当前 e 之前没有出现过数字，返回 fasle ；否则令 hasE = true ，并且将其他 3 个 flag 全部置为 false ，因为要开始遍历 e 后面的新数字了</li>
<li>如果当前字符 c 是 + 或-：如果已经出现过 + 或 - 或者已经出现过数字或者已经出现过 &lsquo;.&rsquo; ，返回 flase ；否则令 hasSign = true</li>
<li>如果当前字符 c 是 &lsquo;.&rsquo; ：如果已经出现过 &lsquo;.&rsquo; 或者已经出现过 &lsquo;e&rsquo; 或 &lsquo;E&rsquo; ，返回 false ；否则令 hasDot = true</li>
<li>如果当前字符 c 是 ' ' ：结束循环，因为可能是末尾的空格了，但也有可能是字符串中间的空格，在循环外继续处理</li>
<li>如果当前字符 c 是除了上面 5 种情况以外的其他字符，直接返回 false</li>
</ul>
</li>
<li>
<p>处理空格，index 相应的后移</p>
</li>
<li>
<p>如果当前索引 index 与字符串长度相等，说明遍历到了末尾，但是还要满足 hasNum 为 true 才可以最终返回 true ，因为如果字符串里全是符号没有数字的话是不行的，而且 e 后面没有数字也是不行的，但是没有符号是可以的，所以 4 个 flag 里只要判断一下 hasNum 就行；所以最后返回的是 hasNum &amp;&amp; index == n</p>
</li>
<li>
<p>如果字符串中间有空格，按以上思路是无法遍历到末尾的，index 不会与 n 相等，返回的就是 false</p>
</li>
</ol>
<h3 id="复杂度分析-2">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n)</p>
<p><strong>空间复杂度</strong>：O(1)</p>
<h3 id="code-2">Code：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">hasNum</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">hasE</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">hasSign</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">hasDot</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span>
            <span class="n">index</span><span class="o">++;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="o">){</span>
                <span class="n">index</span><span class="o">++;</span>
                <span class="n">hasNum</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">n</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;e&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hasE</span> <span class="o">||</span> <span class="o">!</span><span class="n">hasNum</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">hasE</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">hasNum</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="n">hasSign</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="n">hasDot</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hasSign</span> <span class="o">||</span> <span class="n">hasNum</span> <span class="o">||</span> <span class="n">hasDot</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">hasSign</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hasDot</span> <span class="o">||</span> <span class="n">hasE</span><span class="o">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">hasDot</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">index</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span>
            <span class="n">index</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">hasNum</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">==</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/</a></p>
<p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/</a></p>
<p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/jian-zhi-offer-20-biao-shi-shu-zhi-de-zi-060v/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/jian-zhi-offer-20-biao-shi-shu-zhi-de-zi-060v/</a></p>
]]></description>
</item><item>
    <title>28、剑指 Offer 36. 二叉搜索树与双向链表</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/28.html</link>
    <pubDate>Sat, 02 Oct 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/28.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 36. 二叉搜索树与双向链表</a> 难度中等</p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p>
<a class="lightgallery" href="/post_images/image-20211012010418456.png" title="/post_images/image-20211012010418456.png" data-thumbnail="/post_images/image-20211012010418456.png">
        
    </a>
<!-- raw HTML omitted -->
<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<a class="lightgallery" href="/post_images/image-20211012010457456.png" title="/post_images/image-20211012010457456.png" data-thumbnail="/post_images/image-20211012010457456.png">
        
    </a>
<!-- raw HTML omitted -->
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<p><strong>注意</strong>：本题与主站 426 题相同：<a href="https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p>
<p><strong>注意</strong>：此题对比原题有改动。</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21中序遍历">2.1、中序遍历</h2>
<h3 id="核心思路">核心思路</h3>
<p>本文解法基于性质：二叉搜索树的中序遍历为 <strong>递增序列</strong> 。
将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p>
<ol>
<li><strong>排序链表</strong>： 节点应从小到大排序，因此应使用 <strong>中序遍历</strong> “从小到大”访问树的节点。</li>
<li><strong>双向链表</strong>： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。</li>
<li><strong>循环链表</strong>： 设链表头节点 <code>head</code> 和尾节点 <code>tail</code> ，则应构建 <code>head.left = tail</code> 和 <code>tail.right = head</code> 。</li>
</ol>
<a class="lightgallery" href="/post_images/image-20211012125258456.png" title="/post_images/image-20211012125258456.png" data-thumbnail="/post_images/image-20211012125258456.png">
        
    </a>
<!-- raw HTML omitted -->
<p><strong>中序遍历</strong> 为对二叉树作 “左、根、右” 顺序遍历，递归实现如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 打印中序遍历
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
    <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span> <span class="c1">// 左
</span><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span> <span class="c1">// 根
</span><span class="c1"></span>    <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span> <span class="c1">// 右
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>根据以上分析，考虑使用中序遍历访问树的各节点 cur ；并在访问每个节点时构建 cur 和前驱节点 pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。</p>
<h4 id="算法流程">算法流程</h4>
<p><strong>dfs(cur): 递归法中序遍历</strong>：</p>
<ol>
<li>终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；</li>
<li>递归左子树，即 dfs(cur.left) ；</li>
<li>构建链表：
<ol>
<li>当 pre 为空时： 代表正在访问链表头节点，记为 head ；</li>
<li>当 pre 不为空时： 修改双向节点引用，即 pre.right = cur ， cur.left = pre ；</li>
<li>保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre ；</li>
</ol>
</li>
<li>递归右子树，即 dfs(cur.right) ；</li>
</ol>
<p><strong>treeToDoublyList(root)</strong>：</p>
<ol>
<li>特例处理： 若节点 root 为空，则直接返回；</li>
<li>初始化： 空节点 pre ；</li>
<li>转化为双向链表： 调用 dfs(root) ；</li>
<li>构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可；</li>
<li>返回值： 返回链表的头节点 head 即可；</li>
</ol>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N)，N 为二叉树的节点数，中序遍历需要访问所有节点。</p>
<p><strong>空间复杂度</strong>：O(N)，最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">pre</span><span class="o">,</span> <span class="n">head</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">treeToDoublyList</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 中序遍历, 构建双向链表
</span><span class="c1"></span>        <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="c1">// 此时中序遍历已经完成, head 指向头节点, pre 指向尾节点
</span><span class="c1"></span>
        <span class="c1">// 下面进行头节点和尾节点的相互指向, 这两句的顺序也是可以颠倒的,
</span><span class="c1"></span>
        <span class="c1">// 将头结点的 left 指向尾结点
</span><span class="c1"></span>        <span class="n">head</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
        <span class="c1">// 将尾结点的 right 指向头结点
</span><span class="c1"></span>        <span class="n">pre</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Node</span> <span class="n">cur</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 终止条件：当节点 cur 为空，代表越过叶节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 直接返回
</span><span class="c1"></span>            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 递归左子树
</span><span class="c1"></span>        <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>

        <span class="c1">// 构建链表
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 当 pre 不为空时：修改双向节点引用
</span><span class="c1"></span>            <span class="n">pre</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 当 pre 为空时, 代表正在访问链表头节点
</span><span class="c1"></span>            <span class="n">head</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
        <span class="c1">// 保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre
</span><span class="c1"></span>        <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>

        <span class="c1">// 递归右子树
</span><span class="c1"></span>        <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/</a></p>
]]></description>
</item><item>
    <title>27、剑指 Offer 17. 打印从1到最大的n位数</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/27.html</link>
    <pubDate>Fri, 01 Oct 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/27.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 17. 打印从1到最大的n位数</a> 难度简单</p>
<p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p><strong>示例 1:</strong></p>
<pre tabindex="0"><code>输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
</code></pre><p>说明：</p>
<ul>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数</li>
</ul>
<h1 id="二解法">二、解法</h1>
<p>这道题在面试环节时，基本都要考察大数情况的。</p>
<h2 id="21迭代法">2.1、迭代法</h2>
<h3 id="核心思路">核心思路</h3>
<p>由于本题要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内，因此不考虑大数越界问题。</p>
<p>只需定义区间 $[1, 10^n - 1]$ 和步长 1 ，通过 for 循环生成结果列表并返回即可。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：$O(10^n)$，生成长度为 $10^n$ 的列表需使用 $O(10^n)$ 时间。</p>
<p><strong>空间复杂度</strong>： $O(1)$，建立列表需使用 $O(1)$ 大小的额外空间（ 列表作为返回结果，不计入额外空间 ）。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">printNumbers</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">10</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22大数打印解法">2.2、大数打印解法</h2>
<h3 id="核心思路-1">核心思路</h3>
<p>实际上，本题的主要考点是大数越界情况下的打印。需要解决以下三个问题：</p>
<ol>
<li>
<p>表示大数的变量类型
无论是 short / int / long &hellip; 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。</p>
</li>
<li>
<p>生成数字的字符串集</p>
</li>
</ol>
<ul>
<li>使用 int 类型时，每轮可通过 +1 生成下个数字，而此方法无法应用至 String 类型。并且， String 类型的数字的进位操作效率较低，例如 &ldquo;9999&rdquo; 至 &ldquo;10000&rdquo; 需要从个位到千位循环判断，进位 4 次。</li>
<li>观察可知，生成的列表实际上是 n 位 0 - 9 的 <strong>全排列</strong> ，因此可避开进位操作，通过递归生成数字的 String 列表。</li>
</ul>
<ol start="3">
<li>递归生成全排列</li>
</ol>
<p>基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。例如当 n = 2 时（数字范围 1 - 99 ），固定十位为 0 - 9 ，按顺序依次开启递归，固定个位 0 - 9 ，终止递归并添加数字字符串。</p>
<!-- raw HTML omitted -->
<a class="lightgallery" href="/post_images/image-20211011153020456.png" title="/post_images/image-20211011153020456.png" data-thumbnail="/post_images/image-20211011153020456.png">
        
    </a>
<p>根据以上方法，可初步编写全排列代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">StringBuilder</span> <span class="n">answer</span><span class="o">;</span> <span class="c1">// 解
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// 题目给定的 n
</span><span class="c1"></span>    <span class="kt">char</span><span class="o">[]</span> <span class="n">num</span><span class="o">,</span> <span class="n">charset</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;0&#39;</span><span class="o">,</span> <span class="sc">&#39;1&#39;</span><span class="o">,</span> <span class="sc">&#39;2&#39;</span><span class="o">,</span> <span class="sc">&#39;3&#39;</span><span class="o">,</span> <span class="sc">&#39;4&#39;</span><span class="o">,</span> <span class="sc">&#39;5&#39;</span><span class="o">,</span> <span class="sc">&#39;6&#39;</span><span class="o">,</span> <span class="sc">&#39;7&#39;</span><span class="o">,</span> <span class="sc">&#39;8&#39;</span><span class="o">,</span> <span class="sc">&#39;9&#39;</span><span class="o">};</span> <span class="c1">// num=缓冲区, charset=字符集
</span><span class="c1"></span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">printNumbers</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span> <span class="c1">// 数字字符串集
</span><span class="c1"></span>        <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">// 定义长度为 n 的字符列表
</span><span class="c1"></span>        <span class="n">dfs</span><span class="o">(</span><span class="n">0</span><span class="o">);</span> <span class="c1">// 开启全排列递归
</span><span class="c1"></span>        <span class="n">answer</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">answer</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// 删除最后多余的逗号
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">answer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> <span class="c1">// 转化为字符串并返回
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 终止条件：已固定完所有位
</span><span class="c1"></span>            <span class="n">answer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span><span class="o">);</span> <span class="c1">// 拼接 num 并添加至 res 尾部，使用逗号隔开
</span><span class="c1"></span>            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">i</span> <span class="o">:</span> <span class="n">charset</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 遍历 ‘0‘ - ’9‘
</span><span class="c1"></span>            <span class="n">num</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// 固定第 x 位为 i
</span><span class="c1"></span>            <span class="n">dfs</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// 开启固定第 x + 1 位
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在此方法下，各数字字符串被逗号隔开，共同组成长字符串。返回的数字集字符串如下所示：</p>
<pre tabindex="0"><code>输入：n = 1
输出：&quot;0,1,2,3,4,5,6,7,8,9&quot;

输入：n = 2
输出：&quot;00,01,02,...,10,11,12,...,97,98,99&quot;

输入：n = 3
输出：&quot;000,001,002,...,100,101,102,...,997,998,999&quot;
</code></pre><p>观察可知，当前的生成方法仍有以下问题：</p>
<ol>
<li>诸如 00, 01, 02, ⋯ 应显示为 0, 1, 2, ⋯ ，即应 <strong>删除高位多余的 0</strong> ;</li>
<li>此方法从 0 开始生成，而题目要求 <strong>列表从 1 开始</strong> ；</li>
</ol>
<p>以上两个问题的解决方法如下：</p>
<ol>
<li>
<p>改造上述实现的 dfs(x) 函数</p>
<ul>
<li>
<p>令其成为“dfs(x,n) = 生成长度为 n 的数字字符串，当前正在确定下标为 x 的那一位”，这样可以将不同位长的数值全排列拆分出来。</p>
</li>
<li>
<p>原先的 dfs(3) 要将 1~3 位的数值全排列全部计算出来，改造后将会拆分为 dfs(0,1)+dfs(0,2)+dfs(0,3)。</p>
</li>
</ul>
</li>
<li>
<p>在字符集上做文章</p>
<ul>
<li>通过判断 dfs(x,n) 中 x 是否为 0 ，若是，说明当前还在固定下标为 0 的那一位, 即第一位数字（数值的最高位）,此时只需遍历字符集的 &lsquo;1&rsquo;~&lsquo;9&rsquo;, 反之则遍历 &lsquo;0&rsquo;~&lsquo;9&rsquo;</li>
</ul>
</li>
</ol>
<p>通过上述两个步骤，即可解决上述的两个问题。</p>
<h3 id="复杂度分析-1">复杂度分析</h3>
<p><strong>时间复杂度</strong>：$O(10^n)$，生成长度为 $10^n$ 的列表需使用 $O(10^n)$ 时间。</p>
<p><strong>空间复杂度</strong>： $O(10^n)$，结果列表的长度为 $10^n-1$ ，各数字字符串的长度区间为 $1, 2, &hellip;, n$ ，因此占用 $O(10^n)$ 大小的额外空间。</p>
<h3 id="code-1">Code</h3>
<p>为 <strong>正确表示大数</strong> ，以下代码的返回值为数字字符串集拼接而成的长字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">// 解
</span><span class="c1"></span>    <span class="n">StringBuilder</span> <span class="n">answer</span><span class="o">;</span>
    <span class="c1">// 字符集
</span><span class="c1"></span>    <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;0&#39;</span><span class="o">,</span> <span class="sc">&#39;1&#39;</span><span class="o">,</span> <span class="sc">&#39;2&#39;</span><span class="o">,</span> <span class="sc">&#39;3&#39;</span><span class="o">,</span> <span class="sc">&#39;4&#39;</span><span class="o">,</span> <span class="sc">&#39;5&#39;</span><span class="o">,</span> <span class="sc">&#39;6&#39;</span><span class="o">,</span> <span class="sc">&#39;7&#39;</span><span class="o">,</span> <span class="sc">&#39;8&#39;</span><span class="o">,</span> <span class="sc">&#39;9&#39;</span><span class="o">};</span>
    <span class="c1">// 缓冲区
</span><span class="c1"></span>    <span class="kt">char</span><span class="o">[]</span> <span class="n">num</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">printNumbers</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 结果
</span><span class="c1"></span>        <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>

        <span class="c1">// 开启全排列递归
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 定义长度为 n 的字符数组缓冲区
</span><span class="c1"></span>            <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">// 生成长度为 n 的数字字符串，正在确定下标为 0 的那一位
</span><span class="c1"></span>            <span class="n">dfs</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 删除最后多余的逗号
</span><span class="c1"></span>        <span class="n">answer</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">answer</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="c1">// 转化为字符串并返回
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">answer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 生成长度为 n 的数字字符串，当前正在确定下标为 x 的那一位（缓冲区 num 的数组下标）
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 终止条件：已固定完所有位
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 拼接 num 并添加至 res 尾部，使用逗号隔开
</span><span class="c1"></span>            <span class="n">answer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 去除前导0：若当前还在固定下标为 0 的那一位, 则说明是第一位数字（即数值最高位）, 只遍历字符集的 &#39;1&#39;~&#39;9&#39;, 反之则遍历 &#39;0&#39;~&#39;9&#39;
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 固定第 x 位为 i, 对应到缓冲区下标为 x-1
</span><span class="c1"></span>            <span class="n">num</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
            <span class="c1">// 开启固定第 x + 1 位
</span><span class="c1"></span>            <span class="n">dfs</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>本题要求输出 int 类型数组。为 <strong>运行通过</strong> ，可在添加数字字符串 s 前，将其转化为 int 类型。代码如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">// 当前已求解数字个数, 作为游标使用
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="c1">// 解
</span><span class="c1"></span>    <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span><span class="o">;</span>

    <span class="c1">// 字符集
</span><span class="c1"></span>    <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="o">{</span><span class="sc">&#39;0&#39;</span><span class="o">,</span> <span class="sc">&#39;1&#39;</span><span class="o">,</span> <span class="sc">&#39;2&#39;</span><span class="o">,</span> <span class="sc">&#39;3&#39;</span><span class="o">,</span> <span class="sc">&#39;4&#39;</span><span class="o">,</span> <span class="sc">&#39;5&#39;</span><span class="o">,</span> <span class="sc">&#39;6&#39;</span><span class="o">,</span> <span class="sc">&#39;7&#39;</span><span class="o">,</span> <span class="sc">&#39;8&#39;</span><span class="o">,</span> <span class="sc">&#39;9&#39;</span><span class="o">};</span>
    <span class="c1">// 缓冲区
</span><span class="c1"></span>    <span class="kt">char</span><span class="o">[]</span> <span class="n">num</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">printNumbers</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 根据解的已知个数初始化空间
</span><span class="c1"></span>        <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">10</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>

        <span class="c1">// 开启全排列递归
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 定义长度为 n 的字符数组缓冲区
</span><span class="c1"></span>            <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">// 生成长度为 n 的数字字符串，正在确定下标为 0 的那一位
</span><span class="c1"></span>            <span class="n">dfs</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 转化为字符串并返回
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 生成长度为 n 的数字字符串，当前正在确定下标为 x 的那一位（缓冲区 num 的数组下标）
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 终止条件：已固定完所有位
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 将缓冲区的字符串转换为 int , 加入解
</span><span class="c1"></span>            <span class="n">answer</span><span class="o">[</span><span class="n">count</span><span class="o">++]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">num</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 去除前导0：若当前还在固定下标为 0 的那一位, 则说明是第一位数字（即数值最高位）, 只遍历字符集的 &#39;1&#39;~&#39;9&#39;, 反之则遍历 &#39;0&#39;~&#39;9&#39;
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 固定第 x 位为 i, 对应到缓冲区下标为 x-1
</span><span class="c1"></span>            <span class="n">num</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
            <span class="c1">// 开启固定第 x + 1 位
</span><span class="c1"></span>            <span class="n">dfs</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/</a></p>
]]></description>
</item><item>
    <title>26、剑指 Offer 05. 替换空格</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/26.html</link>
    <pubDate>Thu, 30 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/26.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 05. 替换空格</a> 难度简单</p>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成&quot;%20&quot;。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;We are happy.&quot;
输出：&quot;We%20are%20happy.&quot;
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= s 的长度 &lt;= 10000
</code></pre><h1 id="二解法">二、解法</h1>
<h2 id="21遍历添加">2.1、遍历添加</h2>
<h3 id="核心思路">核心思路</h3>
<p>在 Python 和 Java 等语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N)。遍历使用 O(N)，每轮添加（修改）字符操作使用 O(1)；</p>
<p><strong>空间复杂度</strong>：O(N)。新建的 StringBuilder 使用了线性大小的额外空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">replaceSpace</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">Character</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;%20&#34;</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22string-内置-replace-函数">2.2、String 内置 replace 函数</h2>
<h3 id="核心思路-1">核心思路</h3>
<p>不说了，懂得都懂。</p>
<h3 id="复杂度分析-1">复杂度分析</h3>
<p><strong>时间复杂度</strong>：</p>
<p><strong>空间复杂度</strong>：</p>
<h3 id="code-1">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">replaceSpace</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&#34; &#34;</span><span class="o">,</span> <span class="s">&#34;%20&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/</a></p>
]]></description>
</item><item>
    <title>25、剑指 Offer 45. 把数组排成最小的数</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/25.html</link>
    <pubDate>Wed, 29 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/25.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 45. 把数组排成最小的数</a> 难度中等</p>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p><strong>示例 1:</strong></p>
<pre tabindex="0"><code>输入: [10,2]
输出: &quot;102&quot;
</code></pre><p><strong>示例 2:</strong></p>
<pre tabindex="0"><code>输入: [3,30,34,5,9]
输出: &quot;3033459&quot;
</code></pre><p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt; nums.length &lt;= 100</code></li>
</ul>
<p><strong>说明:</strong></p>
<ul>
<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li>
</ul>
<h1 id="二解法">二、解法</h1>
<h2 id="21自定义规则排序">2.1、自定义规则排序</h2>
<h3 id="核心思路">核心思路</h3>
<p>此题求拼接起来的最小数字，本质上是一个排序问题。设数组 nums 中任意两数字的字符串为 x 和 y ，则规定 <strong>排序判断规则</strong> 为：</p>
<ul>
<li>若拼接字符串 x + y &gt; y + x，则 x 的权重比 y 大；</li>
<li>反之，若 x + y &lt; y + x，则 y 的权重比 x 大；</li>
</ul>
<p>排序完成后，权重大的数排前面，权重小的数排后面。根据以上规则，套用任何排序方法对 nums 执行排序即可。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N logN) ，N 为最终返回值的字符数量（ strs 列表的长度 ≤ N ）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N^2)。</p>
<p><strong>空间复杂度</strong>：O(N) ，字符串列表 strs 占用线性大小的额外空间。</p>
<h3 id="code">Code</h3>
<p>内置排序</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">minNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// nums[] -&gt; string[]
</span><span class="c1"></span>        <span class="n">String</span><span class="o">[]</span> <span class="n">strs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

        <span class="c1">// 自定义规则排序
</span><span class="c1">//        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));
</span><span class="c1"></span>        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span> <span class="n">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="o">).</span><span class="na">compareTo</span><span class="o">((</span><span class="n">s2</span> <span class="o">+</span> <span class="n">s1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">// 拼接排序后的结果
</span><span class="c1"></span>        <span class="n">StringBuilder</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">strs</span><span class="o">)</span>
            <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="code-1">Code</h3>
<p>快速排序</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">minNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">strs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="n">StringBuilder</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">strs</span><span class="o">)</span>
            <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span><span class="o">((</span><span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="n">j</span><span class="o">--;</span>
            <span class="k">while</span><span class="o">((</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="n">i</span><span class="o">++;</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
        <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/</a></p>
]]></description>
</item><item>
    <title>24、剑指 Offer 57. 和为s的两个数字</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/24.html</link>
    <pubDate>Tue, 28 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/24.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 57. 和为s的两个数字</a> 难度简单</p>
<p>输入一个递增排序的数组和一个数字 s ，在数组中查找两个数，使得它们的和正好是 s 。如果有多对数字的和等于 s ，则输出任意一对即可。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
</code></pre><p><strong>限制：</strong></p>
<ul>
<li>$ 1 &lt;= nums.length &lt;= 10^5 $</li>
<li>$ 1 &lt;= nums[i] &lt;= 10^6 $</li>
</ul>
<h1 id="二解法">二、解法</h1>
<h2 id="21对撞双指针法">2.1、对撞双指针法</h2>
<h3 id="核心思路">核心思路</h3>
<p>利用 HashMap 可以通过遍历数组找到数字组合，时间和空间复杂度均为 O(N) 。但本题的 $nums$ 是 <strong>排序数组</strong> ，因此可使用 <strong>双指针法</strong> 将空间复杂度降低至 O(1) 。</p>
<h4 id="算法流程"><strong>算法流程</strong>：</h4>
<ol>
<li>
<p><strong>初始化：</strong> 双指针 $i , j$ 分别指向数组 $nums $的左右两端 <em>（俗称对撞双指针）</em>。</p>
</li>
<li>
<p><strong>循环搜索：</strong> 当双指针相遇时跳出；</p>
<ol>
<li>计算和 $s = nums[i] + nums[j]$ ；</li>
<li>若 $s &gt; target$ ，则指针 $j$ 向左移动，即执行 $j = j - 1$ ；</li>
<li>若 $s &lt; target$ ，则指针 $i$ 向右移动，即执行 $i = i + 1$ ；</li>
<li>若 $s = target$ ，立即返回数组 $[ nums[i], nums[j] ]$ ；</li>
</ol>
</li>
<li>
<p>返回空数组，代表无和为 $target$ 的数字组合。</p>
</li>
</ol>
<h4 id="正确性证明">正确性证明：</h4>
<blockquote>
<p>记每个状态为 $S(i, j)$ ，即 $S(i, j) = nums[i] + nums[j]$ 。假设 $S(i, j) &lt; target$ ，则执行 $i = i + 1$ ，即状态切换至 $S(i + 1, j)$ 。</p>
</blockquote>
<ul>
<li>状态 $S(i, j)$ 切换至 $S(i + 1, j)$ ，则会消去一行元素，相当于 消去了状态集合 ${S(i, i + 1), S(i, i + 2), &hellip;, S(i, j - 2), S(i, j - 1), S(i, j) }$ 。（由于双指针都是向中间收缩，因此这些状态之后不可能再遇到）。</li>
<li>由于 $nums$ 是排序数组，因此这些 <strong>消去的状态</strong> 都一定满足 $S(i, j) &lt; target$ ，即这些状态都 <strong>不是解</strong> 。</li>
<li>结论： 以上分析已证明 “每次指针 $i$ 的移动操作，都不会导致解的丢失” ，即指针 $i$ 的移动操作是 安全的 ；同理，对于指针 $j$ 可得出同样推论；因此，此双指针法是正确的。</li>
</ul>
<!-- raw HTML omitted -->
<a class="lightgallery" href="/post_images/image-20211011123131456.png" title="/post_images/image-20211011123131456.png" data-thumbnail="/post_images/image-20211011123131456.png">
        
    </a>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N)，N 为数组 $nums $ 的长度；双指针共同线性遍历整个数组。</p>
<p><strong>空间复杂度</strong>：O(1)，变量 $i, j$ 使用常数大小的额外空间。</p>
<h3 id="code">Code</h3>
<p>因题目限定 $ 1 &lt;= nums[i] &lt;= 10^6 $ ，所以判断条件用相加后的结果不会溢出。如果两个操作数都是正整数，则使用$target - nums[i]$ 跟 $nums[j]$ 比较，这样保证不会溢出。因为 $nums[i]$ 可能是负数， $target - nums[i]$ 也可能越界，因此用 long 型去比可能是最安全的。</p>
<p>同样的例子还有二分查找，$(left + right) / 2$ 可以用 $left + ((rigth - left) &raquo; 1))$ 代替。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>

            <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">--;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">};</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22哈希表">2.2、哈希表</h2>
<h3 id="核心思路-1">核心思路</h3>
<p>使用暴力枚举的时间复杂度较高的原因是寻找 $target - nums[i]$ 的时间复杂度过高。因此，使用哈希表可以将寻找 $target - nums[i]$ 的时间复杂度降低到从 O(N) 降低到 O(1)。</p>
<p>因本题的 $nums$ 是 <strong>排序数组</strong> ，实际上使用 <strong>双指针法</strong> 可以将空间复杂度也降低至 O(1) ，但如果 $nums$ 是无序的，可以使用哈希表解法。</p>
<h3 id="复杂度分析-1">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N)，其中 N 是数组中的元素数量。对于每一个 $nums[i]$ ，我们可以 O(1) 地寻找 $target - nums[i]$ 。</p>
<p><strong>空间复杂度</strong>：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p>
<h3 id="code-1">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 初始化哈希表
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">hashtable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 查询哈希表中是否存在 target - nums[i]
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">hashtable</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="c1">// 如果存在, 返回 [ target - nums[i], nums[i] ]
</span><span class="c1"></span>                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">hashtable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]),</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]};</span>
            <span class="o">}</span>

            <span class="c1">// 将 nums[i] 插入到哈希表中，保证不会让 nums[i] 和自己匹配
</span><span class="c1"></span>            <span class="n">hashtable</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// 没有找到符合条件的解, 返回 [ 0, 0 ]
</span><span class="c1"></span>        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/mian-shi-ti-57-he-wei-s-de-liang-ge-shu-zi-shuang-/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/mian-shi-ti-57-he-wei-s-de-liang-ge-shu-zi-shuang-/</a></p>
<p><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/</a></p>
]]></description>
</item><item>
    <title>23、剑指 Offer 26. 树的子结构</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/23.html</link>
    <pubDate>Sun, 26 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/23.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 26. 树的子结构</a> 难度中等</p>
<p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。</p>
<p>例如:
给定的树 A:</p>
<p>    3<br>
   / \<br>
  4  5<br>
 / \<br>
1  2</p>
<p>给定的树 B：</p>
<p>  4<br>
 /<br>
1</p>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：A = [1,2,3], B = [3,1]
输出：false
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：A = [3,4,5,1,2], B = [4,1]
输出：true
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= 节点个数 &lt;= 10000
</code></pre><h1 id="二解法">二、解法</h1>
<h2 id="21递归法">2.1、递归法</h2>
<h3 id="核心思路">核心思路</h3>
<p>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p>
<ol>
<li>先序遍历树 A 中的每个节点 Na；（对应函数 <code>isSubStructure(A, B)</code>）</li>
<li>判断树 A 中以 Na 为根节点的子树是否包含树 B。（对应函数 <code>recur(A, B)</code>）</li>
</ol>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(MN) ，其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N)。</p>
<p><strong>空间复杂度</strong>：O(M) ，当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSubStructure</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">A</span><span class="o">,</span> <span class="n">TreeNode</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果 A 或 B 为空
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">A</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">B</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// B、A 相同
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">recur</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// B 在 A 的左子树中
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isSubStructure</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// B 在 A 的右子树中
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isSubStructure</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 递归判断树 A 是否包含 树 B
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="nf">recur</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">A</span><span class="o">,</span> <span class="n">TreeNode</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">B</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">A</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">A</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">recur</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">B</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">recur</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">B</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</a></p>
]]></description>
</item><item>
    <title>22、剑指 Offer 37. 序列化二叉树</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/22.html</link>
    <pubDate>Fri, 24 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/22.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 37. 序列化二叉树</a> 难度困难236收藏分享切换为英文接收动态反馈</p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>**提示：**输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode-cn.com/hc/kb/article/1194353/" target="_blank" rel="noopener noreffer">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>示例：</strong></p>
<!-- raw HTML omitted -->
<a class="lightgallery" href="/post_images/image-20210930122450456.jpg" title="/post_images/image-20210930122450456.jpg" data-thumbnail="/post_images/image-20210930122450456.jpg">
        
    </a>
<pre tabindex="0"><code>输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
</code></pre><p>注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21bfs--层序遍历">2.1、BFS / 层序遍历</h2>
<h3 id="核心思路">核心思路</h3>
<p>通常使用的前序、中序、后序、层序遍历记录的二叉树的信息不完整，即唯一的输出序列可能对应着多种二叉树可能性。题目要求的 序列化 和 反序列化 是 可逆操作 。因此，序列化的字符串应携带 完整的二叉树信息 。</p>
<p>观察题目示例，序列化的字符串实际上是二叉树的 “层序遍历”（BFS）结果，本文也采用层序遍历。</p>
<p>为完整表示二叉树，将叶节点下的 null 也记录。在此基础上，对于列表中任意某节点 node ，其左子节点 node.left 和右子节点 node.right 在序列中的位置都是 唯一确定的。</p>
<p>因此，序列化使用层序遍历实现，借助队列，对二叉树做层序遍历，并将越过叶节点的 <code>null</code> 也打印出来。</p>
<p>按照层序遍历的规则，也可实现反序列化。利用队列按层构建二叉树，借助一个指针 i 指向节点 node 的左、右子节点，每构建一个 node 的左、右子节点，指针 i 就向右移动 1 位。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n)，在序列化和反序列化函数中，我们只访问每个节点一次，因此时间复杂度为 O(n)，其中 n 是节点数，即树的大小。</p>
<p><strong>空间复杂度</strong>：最差情况下，队列 <code>queue</code> 同时存储 (N+1)/2 个节点，因此使用 O(N) 额外空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Codec</span> <span class="o">{</span>
    <span class="c1">// 序列化
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">serialize</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 特例处理
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="s">&#34;[]&#34;</span><span class="o">;</span>

        <span class="c1">// 结果
</span><span class="c1"></span>        <span class="n">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(</span><span class="s">&#34;[&#34;</span><span class="o">);</span>
        <span class="c1">// 队列 包含根节点 root
</span><span class="c1"></span>        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="o">}};</span>

        <span class="c1">// 当队列不为空时, 循环处理
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 节点出队, 记为 node
</span><span class="c1"></span>            <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="c1">// 若 node 不为 null
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 将 node.val 拼接到结果中
</span><span class="c1"></span>                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span><span class="o">);</span>
                <span class="c1">// 将 node 的左, 右子节点加入队列, 等待下一轮处理
</span><span class="c1"></span>                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 将 null 拼接到结果中
</span><span class="c1"></span>                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;null,&#34;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 删除末尾的 , 号
</span><span class="c1"></span>        <span class="n">result</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="c1">// 拼接 ] 号
</span><span class="c1"></span>        <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;]&#34;</span><span class="o">);</span>
        <span class="c1">// 将 StringBuilder 转为 String
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 反序列化
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">deserialize</span><span class="o">(</span><span class="n">String</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 特例处理
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;[]&#34;</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

        <span class="c1">// 序列化列表 - 先去掉首尾中括号，再用逗号分割为字符串数组
</span><span class="c1"></span>        <span class="n">String</span><span class="o">[]</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="s">&#34;,&#34;</span><span class="o">);</span>
        <span class="c1">// 根节点 root - 值为 vals[0]
</span><span class="c1"></span>        <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">vals</span><span class="o">[</span><span class="n">0</span><span class="o">]));</span>
        <span class="c1">// 队列 - 包含根节点 root
</span><span class="c1"></span>        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="o">}};</span>

        <span class="c1">// 按层构建, 指针 i
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="c1">// 当队列不为空时, 按层循环构建整棵树
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 节点出队, 记为 node
</span><span class="c1"></span>            <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="c1">// 若 vals[i] 不为 null
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span><span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;null&#34;</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 构建 node 的左子节点：node.left 的值为 vals[i]
</span><span class="c1"></span>                <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
                <span class="c1">// 将 node.left 入队
</span><span class="c1"></span>                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 下标后移一位
</span><span class="c1"></span>            <span class="n">i</span><span class="o">++;</span>

            <span class="c1">// 若 vals[i] 不为 null
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span><span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;null&#34;</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 构建 node 的右子节点：node.left 的值为 vals[i]
</span><span class="c1"></span>                <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">vals</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
                <span class="c1">// 将 node.left 入队
</span><span class="c1"></span>                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 下标后移一位
</span><span class="c1"></span>            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/</a></p>
]]></description>
</item></channel>
</rss>
