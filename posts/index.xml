<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - 無糖的小宇宙</title>
        <link>https://sugarless.top/posts.html</link>
        <description>所有文章 | 無糖的小宇宙</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>jaded@foxmail.com (無糖)</managingEditor>
            <webMaster>jaded@foxmail.com (無糖)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 30 Sep 2021 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://sugarless.top/posts.html" rel="self" type="application/rss+xml" /><item>
    <title>[ 置顶 ] 🚩 Github 项目 / 工具站点 / 有趣的站点</title>
    <link>https://sugarless.top/posts/mark/1.html</link>
    <pubDate>Tue, 31 Dec 2019 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/mark/1.html</guid>
    <description><![CDATA[<p>内容不定期持续更新，感谢每一位开源项目作者为全世界开发者做出的杰出贡献。本文主要分享一些我平时收集到的一些好物，东西可能比较杂乱。涵盖开源项目、免费的工具站、好用的客户端工具、优秀的付费网站和来路不明的沙雕网站。</p>
<h1 id="github-开源项目">Github 开源项目</h1>
<h2 id="功能性网站">功能性网站</h2>
<h3 id="1兰空图床">1、兰空图床</h3>
<p>使用 thinkphp + mysql 开发，界面简洁易用，支持第三方云储存和远程 FTP 存储。并且有开源的浏览器插件支持。（真香）</p>
<p>官网：<a href="https://www.lsky.pro" target="_blank" rel="noopener noreffer">https://www.lsky.pro</a></p>
<p>GitHub：<a href="https://github.com/wisp-x/lsky-pro" target="_blank" rel="noopener noreffer">https://github.com/wisp-x/lsky-pro</a></p>
<p>浏览器扩展：<a href="https://github.com/wisp-x/lsky-pro-chrome-extension" target="_blank" rel="noopener noreffer">https://github.com/wisp-x/lsky-pro-chrome-extension</a></p>
<h3 id="2基于-phphtml-的轻量级网络测试站点">2、基于 php+html 的轻量级网络测试站点</h3>
<p>HTML5 Speedtest 可用于查看下载速度、ping 速度、上传速度；很小巧方便，直接打开页面点击一下 start 就能自动检测，你本机到远程服务器的网络状况，快速得到观测数据</p>
<p>Github：<a href="https://github.com/librespeed/speedtest" target="_blank" rel="noopener noreffer">https://github.com/librespeed/speedtest</a></p>
<h3 id="3flarum-论坛">3、flarum 论坛</h3>
<p>基于 PHP Laravel 框架构建的一款优雅简洁论坛软件。发帖及跟帖回复使用 markdown 语法是一个亮点。</p>
<p>官网：<a href="https://flarum.org" target="_blank" rel="noopener noreffer">https://flarum.org</a></p>
<p>中文官网：<a href="https://flarum.org.cn" target="_blank" rel="noopener noreffer">https://flarum.org.cn</a></p>
<p>Github：<a href="https://github.com/flarum/flarum" target="_blank" rel="noopener noreffer">https://github.com/flarum/flarum</a></p>
<h2 id="命令行工具">命令行工具</h2>
<h3 id="1annie">1、annie</h3>
<p>基于 Go 开发的一款命令行视频下载器，支持的平台很多，包括 MacOS、Windows、Linux 等。目前支持 bilibili 和 youtube 的播放列表批量下载，其他网站只支持单个视频下载。</p>
<p>Github：<a href="https://github.com/iawia002/annie" target="_blank" rel="noopener noreffer">https://github.com/iawia002/annie</a></p>
<h3 id="2youtube-dl">2、youtube-dl</h3>
<p>下载 youtube 视频的神器
Github：<a href="https://github.com/ytdl-org/youtube-dl" target="_blank" rel="noopener noreffer">https://github.com/ytdl-org/youtube-dl</a>
官网：<a href="http://ytdl-org.github.io/youtube-dl/" target="_blank" rel="noopener noreffer">http://ytdl-org.github.io/youtube-dl/</a></p>
<h2 id="开发工具">开发工具</h2>
<h3 id="1anotherredisdesktopmanager">1、AnotherRedisDesktopManager</h3>
<p>一个 GUI Redis 桌面管理器，兼容 Linux、Windows、Mac。更重要的是，在加载大量的键时，它不会崩溃。</p>
<p>Github：<a href="https://github.com/qishibo/AnotherRedisDesktopManager" target="_blank" rel="noopener noreffer">https://github.com/qishibo/AnotherRedisDesktopManager</a></p>
<h3 id="2switchhosts">2、SwitchHosts</h3>
<p>SwitchHosts 是一个管理、切换多个 hosts 方案的工具。</p>
<p>Github：<a href="https://github.com/oldj/SwitchHosts" target="_blank" rel="noopener noreffer">https://github.com/oldj/SwitchHosts</a></p>
<p>官网：<a href="https://swh.app/zh/" target="_blank" rel="noopener noreffer">https://swh.app/zh/</a></p>
<h3 id="3docsify">3、docsify</h3>
<p>docsify 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 index.html 就可以开始编写文档并直接部署在 GitHub Pages。</p>
<p>Github：<a href="https://github.com/docsifyjs/docsify/" target="_blank" rel="noopener noreffer">https://github.com/docsifyjs/docsify/</a></p>
<p>官网：<a href="https://docsify.js.org/" target="_blank" rel="noopener noreffer">https://docsify.js.org/</a></p>
<h2 id="ui-框架">UI 框架</h2>
<h3 id="1layui">1、LayUI</h3>
<p>对非专业前端的开发人员非常友好，组件丰富，极低门槛，开箱即用。</p>
<p>官网：<a href="https://www.layui.com" target="_blank" rel="noopener noreffer">https://www.layui.com</a></p>
<p>GitHub：<a href="https://github.com/sentsin/layui" target="_blank" rel="noopener noreffer">https://github.com/sentsin/layui</a></p>
<h3 id="2vant-weapp">2、vant-weapp</h3>
<p>有赞出品的开源小程序 UI 组件库</p>
<p>官网：<a href="https://youzan.github.io/vant-weapp" target="_blank" rel="noopener noreffer">https://youzan.github.io/vant-weapp</a></p>
<p>GitHub：<a href="https://github.com/youzan/vant-weapp" target="_blank" rel="noopener noreffer">https://github.com/youzan/vant-weapp</a></p>
<h3 id="3elementui">3、ElementUI</h3>
<p>饿了么开发的基于 Vue 2.0 的桌面端组件库</p>
<p>官网：<a href="https://element.eleme.cn" target="_blank" rel="noopener noreffer">https://element.eleme.cn</a></p>
<h2 id="wordpress-主题">WordPress 主题</h2>
<h3 id="1argon-theme">1、argon-theme</h3>
<p>博客、文章向主题</p>
<p>Github：<a href="https://github.com/solstice23/argon-theme" target="_blank" rel="noopener noreffer">https://github.com/solstice23/argon-theme</a></p>
<p>Demo：<a href="https://solstice23.top/archives/746" target="_blank" rel="noopener noreffer">https://solstice23.top/archives/746</a></p>
<h3 id="2puock">2、Puock</h3>
<p>博客、文章主题</p>
<p>Github：<a href="https://github.com/Licoy/wordpress-theme-puock" target="_blank" rel="noopener noreffer">https://github.com/Licoy/wordpress-theme-puock</a></p>
<p>Demo：<a href="https://www.licoy.cn" target="_blank" rel="noopener noreffer">https://www.licoy.cn</a></p>
<h3 id="3webstack">3、WebStack</h3>
<p>网址导航主题</p>
<p>Github：<a href="https://github.com/owen0o0/WebStack" target="_blank" rel="noopener noreffer">https://github.com/owen0o0/WebStack</a></p>
<h2 id="hugo-主题">Hugo 主题</h2>
<h3 id="1doit">1、DoIt</h3>
<p>个人博客主题</p>
<p>Github：<a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer">https://github.com/HEIGE-PCloud/DoIt</a></p>
<p>Demo：<a href="https://hugodoit.pages.dev/zh-cn/" target="_blank" rel="noopener noreffer">https://hugodoit.pages.dev/zh-cn/</a></p>
<h3 id="2hugo-theme-meme">2、hugo-theme-meme</h3>
<p>个人博客主题</p>
<p>Github：<a href="https://github.com/reuixiy/hugo-theme-meme" target="_blank" rel="noopener noreffer">https://github.com/reuixiy/hugo-theme-meme</a></p>
<p>Demo：<a href="https://io-oi.me/" target="_blank" rel="noopener noreffer">https://io-oi.me/</a></p>
<h2 id="javascript">JavaScript</h2>
<h3 id="1introjs">1、intro.js</h3>
<p>网站页面 / 新功能 引导流程插件</p>
<p>官网：<a href="http://introjs.com" target="_blank" rel="noopener noreffer">http://introjs.com</a></p>
<p>GitHub：<a href="https://github.com/usablica/intro.js" target="_blank" rel="noopener noreffer">https://github.com/usablica/intro.js</a></p>
<h3 id="2clipboardjs">2、clipboard.js</h3>
<p>js 实现一键复制文本到剪贴板插件</p>
<p>官网：<a href="https://clipboardjs.com" target="_blank" rel="noopener noreffer">https://clipboardjs.com</a></p>
<p>GitHub：<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener noreffer">https://github.com/zenorocha/clipboard.js</a></p>
<h3 id="3viewerjs">3、viewer.js</h3>
<p>js 图片浏览插件</p>
<p>官网：<a href="https://fengyuanchen.github.io/viewerjs" target="_blank" rel="noopener noreffer">https://fengyuanchen.github.io/viewerjs</a></p>
<p>Github：<a href="https://github.com/fengyuanchen/viewerjs" target="_blank" rel="noopener noreffer">https://github.com/fengyuanchen/viewerjs</a></p>
<h3 id="4contextjs">4、context.js</h3>
<p>右键菜单插件</p>
<p>官网：<a href="http://lab.jakiestfu.com/contextjs" target="_blank" rel="noopener noreffer">http://lab.jakiestfu.com/contextjs</a></p>
<p>Github：<a href="https://github.com/jakiestfu/Context.js" target="_blank" rel="noopener noreffer">https://github.com/jakiestfu/Context.js</a></p>
<h3 id="5momentjs">5、moment.js</h3>
<p>JavaScript 日期处理类库，多语言支持</p>
<p>官网：<a href="https://momentjs.com" target="_blank" rel="noopener noreffer">https://momentjs.com</a> / <a href="http://momentjs.cn" target="_blank" rel="noopener noreffer">http://momentjs.cn</a></p>
<h3 id="6highlightjs">6、highlight.js</h3>
<p>代码高亮 / 支持 189 种编程语言 / 95 种高亮样式</p>
<p>Github：<a href="https://github.com/highlightjs/highlight.js" target="_blank" rel="noopener noreffer">https://github.com/highlightjs/highlight.js</a></p>
<p>官网：<a href="https://highlightjs.org" target="_blank" rel="noopener noreffer">https://highlightjs.org</a> / <a href="https://highlightjs.org/static/demo" target="_blank" rel="noopener noreffer">https://highlightjs.org/static/demo</a></p>
<h3 id="7pangujs">7、Pangu.js</h3>
<p>中文字和英文、数字、符号之间自动插入空格</p>
<p>Github：<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener noreffer">https://github.com/vinta/pangu.js</a></p>
<p>官网：暂无</p>
<h2 id="m3u-直播源">M3U 直播源</h2>
<h3 id="1wtv">1、wtv</h3>
<p>解决电脑、手机看电视直播的苦恼，收集各种直播源，电视直播网站。建议配合 potplayer 使用。</p>
<p>Github：<a href="https://github.com/biancangming/wtv" target="_blank" rel="noopener noreffer">https://github.com/biancangming/wtv</a></p>
<h2 id="客户端软件">客户端软件</h2>
<h3 id="1contextmenumanager">1、ContextMenuManager</h3>
<p>一个纯粹的 Windows 右键菜单管理程序</p>
<p>Github：<a href="https://github.com/BluePointLilac/ContextMenuManager" target="_blank" rel="noopener noreffer">https://github.com/BluePointLilac/ContextMenuManager</a></p>
<p>官网：<a href="https://bluepointlilac.github.io/ContextMenuManager" target="_blank" rel="noopener noreffer">https://bluepointlilac.github.io/ContextMenuManager</a></p>
<h1 id="工具站点">工具站点</h1>
<h2 id="开发">开发</h2>
<h3 id="1requestcatchercom">1、requestcatcher.com</h3>
<p>Debug web hooks, http clients, etc.</p>
<p>Request Catcher will create a subdomain on which you can test an application. All requests sent to any path on the subdomain are forwarded to your browser in real time.</p>
<p>官网：<a href="https://requestcatcher.com" target="_blank" rel="noopener noreffer">https://requestcatcher.com</a></p>
<h3 id="2jsoncn">2、json.cn</h3>
<p>json 格式化</p>
<p>官网：<a href="http://json.cn" target="_blank" rel="noopener noreffer">http://json.cn</a></p>
<h3 id="3searchcode">3、searchcode</h3>
<p>是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。</p>
<p>官网：<a href="https://searchcode.com" target="_blank" rel="noopener noreffer">https://searchcode.com</a></p>
<p>设计
1、创客贴
付费网站，但提供一些免费资源，比较灵活的在线设计工具。风格比较偏向 MG 动画，可以搞出很花哨的 banner 和长图海报之类的，算是个不错的设计资源网站。</p>
<p>官网：<a href="https://www.chuangkit.com" target="_blank" rel="noopener noreffer">https://www.chuangkit.com</a></p>
<h2 id="书籍">书籍</h2>
<h3 id="1鸠摩搜索">1、鸠摩搜索</h3>
<p>鸠摩是一个电子书搜索引擎，界面简洁、内容纯净，专业而高效。</p>
<p>官网：<a href="https://www.jiumodiary.com" target="_blank" rel="noopener noreffer">https://www.jiumodiary.com</a></p>
<h3 id="2thefuture-书籍搜索">2、thefuture 书籍搜索</h3>
<p>小站，知名度不高，但试着搜索了几本书，感觉还挺好用。</p>
<p>官网：<a href="https://bks.thefuture.top" target="_blank" rel="noopener noreffer">https://bks.thefuture.top</a></p>
<h3 id="3z-library">3、z-library</h3>
<p>可以找到不少英文原版书籍</p>
<p>官网：<a href="https://zh.z-lib.org/" target="_blank" rel="noopener noreffer">https://zh.z-lib.org/</a></p>
<h3 id="4全国图书馆参考咨询联盟">4、全国图书馆参考咨询联盟</h3>
<p>由中国公共、教育、科技系统 图书馆合作建立的公益性服务机构，能找到不少书籍，但下载比较麻烦。</p>
<p>官网：<a href="http://www.ucdrs.superlib.net/" target="_blank" rel="noopener noreffer">http://www.ucdrs.superlib.net/</a></p>
<h2 id="生产力">生产力</h2>
<h3 id="1gitmind-在线思维导图">1、GitMind 在线思维导图</h3>
<p><a href="https://gitmind.cn" target="_blank" rel="noopener noreffer">https://gitmind.cn</a></p>
<h2 id="图像">图像</h2>
<h3 id="1ai-人工智能图片无损放大">1、AI 人工智能图片无损放大</h3>
<p><a href="https://bigjpg.com" target="_blank" rel="noopener noreffer">https://bigjpg.com</a></p>
<h3 id="2tinypng-图片在线压缩">2、tinypng 图片在线压缩</h3>
<p><a href="https://tinypng.com/" target="_blank" rel="noopener noreffer">https://tinypng.com/</a></p>
<h3 id="3squoosh谷歌图片在线压缩--开源">3、Squoosh（谷歌图片在线压缩 / 开源）</h3>
<p><a href="https://squoosh.app/" target="_blank" rel="noopener noreffer">https://squoosh.app/</a></p>
<h3 id="4消除图片中的背景--ai-自动抠图">4、消除图片中的背景 / AI 自动抠图</h3>
<p><a href="https://www.remove.bg/zh" target="_blank" rel="noopener noreffer">https://www.remove.bg/zh</a></p>
<h3 id="5中国哲学书电子化计划">5、中国哲学书电子化计划</h3>
<p>中国哲学书电子化计划是一个线上开放电子图书馆，为中外学者提供中国历代传世文献，力图超越印刷媒体限制，通过电子科技探索新方式与古代文献进行沟通。收藏的文本已超过三万部著作，并有五十亿字之多，故为历代中文文献资料库最大者。</p>
<p><a href="https://ctext.org/zhs" target="_blank" rel="noopener noreffer">https://ctext.org/zhs</a></p>
<h2 id="内容创作">内容创作</h2>
<h3 id="1emoji大全--emoji表情符号词典-">1、Emoji大全 | Emoji表情符号词典 📓</h3>
<p><a href="https://www.emojiall.com/zh-hans" target="_blank" rel="noopener noreffer">https://www.emojiall.com/zh-hans</a></p>
<h3 id="2deepl-翻译">2、DeepL 翻译</h3>
<p><a href="https://www.deepl.com/translator" target="_blank" rel="noopener noreffer">https://www.deepl.com/translator</a></p>
<h2 id="kms">KMS</h2>
<h3 id="1沧水-kms">1、沧水 KMS</h3>
<p><a href="https://kms.cangshui.net" target="_blank" rel="noopener noreffer">https://kms.cangshui.net</a></p>
<h3 id="2moerats-kms">2、moerats KMS</h3>
<p><a href="https://www.moerats.com/kms" target="_blank" rel="noopener noreffer">https://www.moerats.com/kms</a></p>
<h2 id="其他">其他</h2>
<h3 id="1台风路径查询">1、台风路径查询</h3>
<p><a href="http://typhoon.zjwater.gov.cn" target="_blank" rel="noopener noreffer">http://typhoon.zjwater.gov.cn</a></p>
<h3 id="2黑客模拟器">2、黑客模拟器</h3>
<p><a href="http://geektyper.com" target="_blank" rel="noopener noreffer">http://geektyper.com</a></p>
<h3 id="3世界护照大全">3、世界护照大全</h3>
<p><a href="https://www.passportindex.org/cn" target="_blank" rel="noopener noreffer">https://www.passportindex.org/cn</a></p>
<h3 id="4查无此人--ai-生成人脸">4、查无此人 / AI 生成人脸</h3>
<p><a href="https://thispersondoesnotexist.com" target="_blank" rel="noopener noreffer">https://thispersondoesnotexist.com</a></p>
<h3 id="5网页版-windows93">5、网页版 windows93</h3>
<p><a href="http://www.windows93.net" target="_blank" rel="noopener noreffer">http://www.windows93.net</a></p>
<h3 id="6假装系统在升级">6、假装系统在升级</h3>
<p><a href="http://fakeupdate.net" target="_blank" rel="noopener noreffer">http://fakeupdate.net</a></p>
<h2 id="好像有那么点用">好像有那么点用</h2>
<h3 id="1全历史">1、全历史</h3>
<p><a href="https://www.allhistory.com" target="_blank" rel="noopener noreffer">https://www.allhistory.com</a></p>
<h3 id="2西窗烛--古诗">2、西窗烛 / 古诗</h3>
<p><a href="http://lib.xcz.im/library" target="_blank" rel="noopener noreffer">http://lib.xcz.im/library</a></p>]]></description>
</item><item>
    <title>22、剑指 Offer 05. 替换空格</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/22.html</link>
    <pubDate>Thu, 30 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/22.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 05. 替换空格</a> 难度简单</p>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成&quot;%20&quot;。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：s = &quot;We are happy.&quot;
输出：&quot;We%20are%20happy.&quot;
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= s 的长度 &lt;= 10000
</code></pre><h1 id="二解法">二、解法</h1>
<h2 id="21遍历添加">2.1、遍历添加</h2>
<h3 id="核心思路">核心思路</h3>
<p>在 Python 和 Java 等语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N)。遍历使用 O(N)，每轮添加（修改）字符操作使用 O(1)；</p>
<p><strong>空间复杂度</strong>：O(N)。新建的 StringBuilder 使用了线性大小的额外空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">replaceSpace</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">Character</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;%20&#34;</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22string-内置-replace-函数">2.2、String 内置 replace 函数</h2>
<h3 id="核心思路-1">核心思路</h3>
<p>不说了，懂得都懂。</p>
<h3 id="复杂度分析-1">复杂度分析</h3>
<p><strong>时间复杂度</strong>：</p>
<p><strong>空间复杂度</strong>：</p>
<h3 id="code-1">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">replaceSpace</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">&#34; &#34;</span><span class="o">,</span> <span class="s">&#34;%20&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/</a></p>
]]></description>
</item><item>
    <title>21、剑指 Offer 45. 把数组排成最小的数</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/21.html</link>
    <pubDate>Wed, 29 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/21.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 45. 把数组排成最小的数</a> 难度中等</p>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p><strong>示例 1:</strong></p>
<pre tabindex="0"><code>输入: [10,2]
输出: &quot;102&quot;
</code></pre><p><strong>示例 2:</strong></p>
<pre tabindex="0"><code>输入: [3,30,34,5,9]
输出: &quot;3033459&quot;
</code></pre><p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt; nums.length &lt;= 100</code></li>
</ul>
<p><strong>说明:</strong></p>
<ul>
<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li>
</ul>
<h1 id="二解法">二、解法</h1>
<h2 id="21自定义规则排序">2.1、自定义规则排序</h2>
<h3 id="核心思路">核心思路</h3>
<p>此题求拼接起来的最小数字，本质上是一个排序问题。设数组 nums 中任意两数字的字符串为 x 和 y ，则规定 <strong>排序判断规则</strong> 为：</p>
<ul>
<li>若拼接字符串 x + y &gt; y + x，则 x 的权重比 y 大；</li>
<li>反之，若 x + y &lt; y + x，则 y 的权重比 x 大；</li>
</ul>
<p>排序完成后，权重大的数排前面，权重小的数排后面。根据以上规则，套用任何排序方法对 nums 执行排序即可。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N logN) ，N 为最终返回值的字符数量（ strs 列表的长度 ≤ N ）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N^2)。</p>
<p><strong>空间复杂度</strong>：O(N) ，字符串列表 strs 占用线性大小的额外空间。</p>
<h3 id="code">Code</h3>
<p>内置排序</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">minNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// nums[] -&gt; string[]
</span><span class="c1"></span>        <span class="n">String</span><span class="o">[]</span> <span class="n">strs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

        <span class="c1">// 自定义规则排序
</span><span class="c1">//        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));
</span><span class="c1"></span>        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span> <span class="n">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="o">).</span><span class="na">compareTo</span><span class="o">((</span><span class="n">s2</span> <span class="o">+</span> <span class="n">s1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">// 拼接排序后的结果
</span><span class="c1"></span>        <span class="n">StringBuilder</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">strs</span><span class="o">)</span>
            <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="code-1">Code</h3>
<p>快速排序</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">minNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">strs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="n">StringBuilder</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">strs</span><span class="o">)</span>
            <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span><span class="o">((</span><span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="n">j</span><span class="o">--;</span>
            <span class="k">while</span><span class="o">((</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="n">i</span><span class="o">++;</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
        <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/</a></p>
]]></description>
</item><item>
    <title>20、剑指 Offer 26. 树的子结构</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/20.html</link>
    <pubDate>Tue, 28 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/20.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 26. 树的子结构</a> 难度中等</p>
<p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。</p>
<p>例如:
给定的树 A:</p>
<p>    3<br>
   / \<br>
  4  5<br>
 / \<br>
1  2</p>
<p>给定的树 B：</p>
<p>  4<br>
 /<br>
1</p>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：A = [1,2,3], B = [3,1]
输出：false
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：A = [3,4,5,1,2], B = [4,1]
输出：true
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= 节点个数 &lt;= 10000
</code></pre><h1 id="二解法">二、解法</h1>
<h2 id="21递归法">2.1、递归法</h2>
<h3 id="核心思路">核心思路</h3>
<p>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p>
<ol>
<li>先序遍历树 A 中的每个节点 Na；（对应函数 <code>isSubStructure(A, B)</code>）</li>
<li>判断树 A 中以 Na 为根节点的子树是否包含树 B。（对应函数 <code>recur(A, B)</code>）</li>
</ol>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(MN) ，其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N)。</p>
<p><strong>空间复杂度</strong>：O(M) ，当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSubStructure</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">A</span><span class="o">,</span> <span class="n">TreeNode</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果 A 或 B 为空
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">A</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">B</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// B、A 相同
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">recur</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// B 在 A 的左子树中
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isSubStructure</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// B 在 A 的右子树中
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isSubStructure</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 递归判断树 A 是否包含 树 B
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="nf">recur</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">A</span><span class="o">,</span> <span class="n">TreeNode</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">B</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">A</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">A</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">recur</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">B</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">recur</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">B</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</a></p>
]]></description>
</item><item>
    <title>19、剑指 Offer 59 - I. 滑动窗口的最大值</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/19.html</link>
    <pubDate>Mon, 27 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/19.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 59 - I. 滑动窗口的最大值</a> 难度困难</p>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<p><strong>示例:</strong></p>
<pre tabindex="0"><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre><p><strong>提示：</strong></p>
<p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p>注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21优先队列">2.1、优先队列</h2>
<h3 id="核心思路">核心思路</h3>
<p>对于「最大值」，我们可以想到一种非常合适的数据结构，那就是优先队列（堆），其中的大根堆可以帮助我们实时维护一系列元素中的最大值。</p>
<p>对于本题而言，初始时，我们将数组 nums 的前 k 个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 nums 中的位置出现在滑动窗口左边界的左侧。因此，当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除。</p>
<p>我们不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以在优先队列中存储二元组 (num,index)，表示元素 num 在数组中的下标为 index。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n log n)，其中 n 是数组 nums 的长度。在最坏情况下，数组 nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log n)，因此总时间复杂度为 O(n log n)。</p>
<p><strong>空间复杂度</strong>：O(n)，即为优先队列需要使用的空间。<strong>这里所有的空间复杂度分析都不考虑返回的答案需要的 O(n) 空间，只计算额外的空间使用</strong>。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 边界条件 / 特殊情况
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span> <span class="o">||</span> <span class="n">k</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// 为了方便判断堆顶元素与滑动窗口的位置关系
</span><span class="c1"></span>        <span class="c1">// 我们在优先队列中存储二元组 (num,index)，表示元素 num 在数组中的下标为 index。
</span><span class="c1"></span>        <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;(</span><span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pair1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">pair2</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 值是否相同？
</span><span class="c1"></span>                <span class="c1">// 如果不同,则根据数值大小来判断权重
</span><span class="c1"></span>                <span class="c1">// 如果相同,则根据索引大小来判断权重
</span><span class="c1"></span>                <span class="k">return</span> <span class="n">pair1</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">!=</span> <span class="n">pair2</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">?</span> <span class="n">pair2</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">pair1</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">:</span> <span class="n">pair2</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">pair1</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">// 将数组 nums 的前 k 个元素放入优先队列中
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">});</span>
        <span class="o">}</span>

        <span class="c1">// answer
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
        <span class="c1">// 第一个结果 -&gt; 数组 nums 的前 k 个元素中的最大值 -&gt; 大根堆的堆顶元素
</span><span class="c1"></span>        <span class="n">ans</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="n">0</span><span class="o">];</span>

        <span class="c1">// 循环处理剩下的元素
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 把一个新的元素放入优先队列中
</span><span class="c1"></span>            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">});</span>
            <span class="c1">// 去除出现在滑动窗口左边界的左侧的值，因为这个值永远不可能出现在滑动窗口中了
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="n">1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// 向 answer 中写入当前滑动窗口内的最大值
</span><span class="c1"></span>            <span class="n">ans</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="n">0</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22单调队列">2.2、单调队列</h2>
<h3 id="核心思路-1">核心思路</h3>
<p>借助一个双端队列，存储单调递减的值，记作 deque。滑动窗口每向右移动一格，实时更新一次这个双端队列。如下图所示：</p>
<a class="lightgallery" href="/post_images/image-20210927225830146.png" title="/post_images/image-20210927225830146.png" data-thumbnail="/post_images/image-20210927225830146.png">
        
    </a>
<!-- raw HTML omitted -->
<p>借助 deque 这个双端队列，我们可以将获取滑动窗口内最大值的时间复杂度从 O(k) 降低至 O(1)，这也是本题的难点。</p>
<p>回忆 <a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/" target="_blank" rel="noopener noreffer">剑指Offer 30. 包含 min 函数的栈</a> ，其使用 单调栈 实现了随意入栈、出栈情况下的 O(1) 时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素” 。</p>
<h3 id="复杂度分析-1">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n)，其中 n 为数组 nums 长度；线性遍历 nums 占用 O(n) ；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O(2n) 。</p>
<p><strong>空间复杂度</strong>：O(k) ，双端队列 deque 中最多同时存储 k 个元素（即窗口大小）。</p>
<h3 id="code-1">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 边界条件 / 特殊情况
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span> <span class="o">||</span> <span class="n">k</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>

        <span class="c1">// 双端队列 仅包含窗口内的元素，且严格
</span><span class="c1"></span>        <span class="n">Deque</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// 答案
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>

        <span class="c1">// 未形成窗口
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 删除 deque 中所有小于 nums[i] 的元素
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
                <span class="n">deque</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>

            <span class="c1">// 向 deque 末尾添加新元素 nums[i]
</span><span class="c1"></span>            <span class="n">deque</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">// deque 的第一个元素即为当前窗口的最大值
</span><span class="c1"></span>        <span class="n">answer</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">();</span>

        <span class="c1">// 形成窗口后
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// i-k 是已经在区间外了, 如果首位等于 nums[i-k], 那么说明此时首位值已经不再区间内了，需要删除
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">])</span>
                <span class="n">deque</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>

            <span class="c1">// 删除 deque 中所有小于 nums[i] 的元素
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
                <span class="n">deque</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
            <span class="c1">// 向 deque 末尾添加新元素 nums[i]
</span><span class="c1"></span>            <span class="n">deque</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">// deque 的第一个元素即为当前窗口的最大值
</span><span class="c1"></span>            <span class="n">answer</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/hua-dong-chuang-kou-de-zui-da-zhi-by-lee-ymyo/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/hua-dong-chuang-kou-de-zui-da-zhi-by-lee-ymyo/</a></p>
<p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/</a></p>
]]></description>
</item><item>
    <title>18、剑指 Offer 25. 合并两个排序的链表</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/18.html</link>
    <pubDate>Sun, 26 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/18.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 25. 合并两个排序的链表</a> 难度简单</p>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><strong>示例1：</strong></p>
<pre tabindex="0"><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= 链表长度 &lt;= 1000
</code></pre><p>注意：本题与主站 21 题相同：https://leetcode-cn.com/problems/merge-two-sorted-lists/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21伪节点--迭代">2.1、伪节点 + 迭代</h2>
<h3 id="核心思路">核心思路</h3>
<p>根据题目描述， 链表 L1 和 L2 是递增的，因此容易想到使用双指针遍历两链表，根据值的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。</p>
<p>引入伪头节点： 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 dumdum 作为合并链表的伪头节点，将各节点添加至 dumdum 之后。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(M+N) ：M,N 分别为链表 L1, L2 的长度，合并操作需遍历两链表。</p>
<p><strong>空间复杂度</strong>：O(1)：节点引用 result, cursor 使用常数大小的额外空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">mergeTwoLists</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="n">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 初始化 result，生成一个伪节点，让其充当链表头
</span><span class="c1"></span>        <span class="n">ListNode</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
        <span class="c1">// 游标
</span><span class="c1"></span>        <span class="n">ListNode</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">result</span><span class="o">;</span>

        <span class="c1">// 当 l1 与 l2 都不为 null 时
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cursor</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span><span class="o">;</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">cursor</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cursor</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 如果其中一个为 null, 则将另外一个链表的所有元素都拼接到 result 后面
</span><span class="c1"></span>        <span class="n">cursor</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">l1</span> <span class="o">:</span> <span class="n">l2</span><span class="o">;</span>
        <span class="c1">// 返回伪节点的后续所有结点
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/mian-shi-ti-25-he-bing-liang-ge-pai-xu-de-lian-b-2/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/mian-shi-ti-25-he-bing-liang-ge-pai-xu-de-lian-b-2/</a></p>
]]></description>
</item><item>
    <title>17、剑指 Offer 13. 机器人的运动范围</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/17.html</link>
    <pubDate>Thu, 23 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/17.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<h4 id="剑指-offer-13-机器人的运动范围httpsleetcode-cncomproblemsji-qi-ren-de-yun-dong-fan-wei-lcof-难度中等"><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 13. 机器人的运动范围</a> 难度中等</h4>
<p>地上有一个 m 行 n 列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18 。但它不能进入方格 [35, 38]，因为 3+5+3+8=19 。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：m = 2, n = 3, k = 1
输出：3
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：m = 3, n = 1, k = 0
输出：1
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<h1 id="二解法">二、解法</h1>
<h2 id="21dfs--剪枝">2.1、DFS + 剪枝</h2>
<h3 id="核心思路">核心思路</h3>
<p>如果我们将行坐标和列坐标数位之和大于 <code>k</code> 的格子看作障碍物，那么这道题就是一道很传统的搜索题目，我们可以使用广度优先搜索或者深度优先搜索来解决它。与 <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/" target="_blank" rel="noopener noreffer">矩阵中的路径</a> 类似，是典型的<code>搜索 &amp; 回溯</code>问题。</p>
<p>但需要注意的是，本题不是要求找<code>最长路径</code>，而是可达坐标的累计数量。也就是说不需要将<code>走过</code>的路径恢复至<code>未走过</code>的状态，只需要统计<code>走过</code>的格子的累计数量最大值即可。</p>
<p>使用一个<code>m * n</code>大小的矩阵存储所有单元格的索引，记作 visited。借助这个访问记录矩阵，你就可以知道机器人已经走过了哪些格子，在这个过程中就可以统计走过的格子数量了。</p>
<p>同时这道题还有一个隐藏的优化：我们在搜索的过程中搜索方向可以缩减为向右和向下，而不必再向上和向左进行搜索。</p>
<p>矩阵中 <strong>满足数位和的解</strong> 构成的几何形状形如多个 <strong>等腰直角三角形</strong> 。</p>
<p></p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(MN) ，最差情况下，机器人遍历矩阵所有单元格。</p>
<p><strong>空间复杂度</strong>：最差情况下，<code>visited</code> 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">// 访问记录矩阵
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">visited</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="c1">// 参数
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

    <span class="c1">// 入口
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">movingCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 初始化矩阵访问记录
</span><span class="c1"></span>        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// 初始化参数
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>

        <span class="c1">// 起点坐标
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">move</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 以 row, column 为起点移动一步
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">move</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">column</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 检查 row, column 是否超限
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">m</span> <span class="o">||</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">column</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 检查坐标是否合法
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">checkXY</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">k</span><span class="o">)</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 检查该坐标是否已经走过
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">max</span> <span class="o">+=</span> <span class="n">1</span><span class="o">;</span>

        <span class="c1">// 写入访问记录, 防止重复访问
</span><span class="c1"></span>        <span class="n">visited</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>

        <span class="c1">// 上下左右四个方向递归调用
</span><span class="c1">//        max = Math.max(max, move(row - 1, column, max));
</span><span class="c1"></span>        <span class="n">max</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">move</span><span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">column</span><span class="o">,</span> <span class="n">max</span><span class="o">));</span>
<span class="c1">//        max = Math.max(max, move(row, column - 1, max));
</span><span class="c1"></span>        <span class="n">max</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">move</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">max</span><span class="o">));</span>


        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 检查坐标是否合法
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">checkXY</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 边界条件
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 计算 x y 的数位和
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">shuWeiSum</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">shuWeiSum</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">?</span> <span class="kc">false</span> <span class="o">:</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 求 number 的数位和
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">shuWeiSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">number</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">number</span> <span class="o">%</span> <span class="n">10</span><span class="o">;</span>
            <span class="n">number</span> <span class="o">/=</span> <span class="n">10</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22bfs">2.2、BFS</h2>
<h3 id="核心思路-1">核心思路</h3>
<p>BFS 和 DFS 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。通常利用队列实现 BFS 。</p>
<h3 id="复杂度分析-1">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(MN) ，最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。</p>
<p><strong>空间复杂度</strong>：O(MN) ，最差情况下，<code>visited</code> 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。</p>
<h3 id="code-1">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">movingCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 辅助矩阵
</span><span class="c1"></span>        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// 可达坐标累计个数
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="c1">// 等待访问的坐标队列
</span><span class="c1"></span>        <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;();</span>
        <span class="c1">// 设置初始坐标
</span><span class="c1"></span>        <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">0</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">0</span><span class="o">});</span>

        <span class="c1">// 循环访问, 直到坐标队列为空
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 取数
</span><span class="c1"></span>            <span class="kt">int</span><span class="o">[]</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="c1">// 获取当前坐标行列值
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">column</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">[</span><span class="n">1</span><span class="o">];</span>

            <span class="c1">// 检查行列坐标是否超限
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">column</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 检查坐标是否符合规则（障碍物判断）
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">checkXY</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 检查该坐标是否已被访问过
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 标记当前坐标已经访问过
</span><span class="c1"></span>            <span class="n">visited</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="c1">// 累计可达坐标+1
</span><span class="c1"></span>            <span class="n">result</span><span class="o">++;</span>

            <span class="c1">// 加入下方向的坐标
</span><span class="c1"></span>            <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">row</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">column</span><span class="o">});</span>
            <span class="c1">// 加入右方向的坐标
</span><span class="c1"></span>            <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span> <span class="o">+</span> <span class="n">1</span><span class="o">});</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 检查坐标是否合法
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">checkXY</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 边界条件
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 计算 x y 的数位和
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">shuWeiSum</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">shuWeiSum</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">?</span> <span class="kc">false</span> <span class="o">:</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 求 number 的数位和
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">shuWeiSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">number</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">number</span> <span class="o">%</span> <span class="n">10</span><span class="o">;</span>
            <span class="n">number</span> <span class="o">/=</span> <span class="n">10</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/ben-ti-he-qi-ta-hui-su-suan-fa-de-ti-mu-ir9le/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/ben-ti-he-qi-ta-hui-su-suan-fa-de-ti-mu-ir9le/</a></p>
<p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/ji-qi-ren-de-yun-dong-fan-wei-by-leetcode-solution/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/ji-qi-ren-de-yun-dong-fan-wei-by-leetcode-solution/</a></p>
]]></description>
</item><item>
    <title>16、剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/16.html</link>
    <pubDate>Mon, 20 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/16.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 10- II. 青蛙跳台阶问题</a> 难度简单</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：n = 2
输出：2
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：n = 7
输出：21
</code></pre><p><strong>示例 3：</strong></p>
<pre tabindex="0"><code>输入：n = 0
输出：1
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<p>注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21动态规划">2.1、动态规划</h2>
<h3 id="核心思路">核心思路</h3>
<p>此类求 <em>多少种可能性</em> 的题目一般都有 <strong>递推性质</strong> ，即 <code>f(n)</code> 和 <code>f(n-1) ... f(1)</code> 之间是有联系的。</p>
<p>设跳上 <code>n</code> 级台阶有 <code>f(n)</code> 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： <strong>跳上 1 级或 2 级台阶</strong>。</p>
<ul>
<li>当为 <code>1</code> 级台阶： 剩 <code>n-1</code> 个台阶，此情况共有 <code>f(n-1)</code> 种跳法；</li>
<li>当为 <code>2</code> 级台阶： 剩 <code>n-2</code> 个台阶，此情况共有 <code>f(n-2)</code> 种跳法。</li>
</ul>
<p><code>f(n)</code> 为以上两种情况之和，即 <code>f(n)=f(n-1)+f(n-2)</code> ，以上递推性质为斐波那契数列。本题可转化为 求斐波那契数列第 n 项的值。与 <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/" target="_blank" rel="noopener noreffer">面试题10- I. 斐波那契数列</a> 等价，唯一的不同在于起始数字不同。</p>
<ul>
<li>
<p>青蛙跳台阶问题： <code>f(0)=1 , f(1)=1 , f(2)=2</code> ；</p>
</li>
<li>
<p>斐波那契数列问题： <code>f(0)=0 , f(1)=1 , f(2)=1</code> 。</p>
</li>
</ul>
<a class="lightgallery" href="/post_images/image-20210921222328456.png" title="/post_images/image-20210921222328456.png" data-thumbnail="/post_images/image-20210921222328456.png">
        
    </a>
<!-- raw HTML omitted -->
<p>本题如果使用递归实现，时间会超限，因此使用循环。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N) ， 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。</p>
<p><strong>空间复杂度</strong>：O(1) ，几个标志变量使用常数大小的额外空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numWays</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">1</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">1</span><span class="o">,</span> <span class="n">c</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">%</span> <span class="n">1000000007</span><span class="o">;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/</a></p>
]]></description>
</item><item>
    <title>15、剑指 Offer 40. 最小的k个数</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/15.html</link>
    <pubDate>Fri, 17 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/15.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 40. 最小的k个数</a> 难度简单</p>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：arr = [0,1,2,1], k = 1
输出：[0]
</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
<h1 id="二解法">二、解法</h1>
<h2 id="21排序面试时也许会被直接-pass-不推荐使用">2.1、排序（面试时也许会被直接 PASS ，不推荐使用）</h2>
<h3 id="核心思路">核心思路</h3>
<p>对原数组从小到大排序后取出前 <code>k</code> 个数即可。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n log n)，其中 n 是数组 <code>arr</code> 的长度，算法的时间复杂度即排序的时间复杂度。</p>
<p><strong>空间复杂度</strong>：O(log n)，排序所需额外的空间复杂度为 O(log n)。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">getLeastNumbers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>

        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="22快速排序思想">2.2、快速排序思想</h2>
<h3 id="核心思路-1">核心思路</h3>
<p>题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 最小的 k 个数 和 其他数字 两部分即可，而快速排序的哨兵划分可完成此目标。</p>
<p>根据快速排序原理，如果某次哨兵划分后 基准数正好是第 k+1 小的数字 ，那么此时基准数左边的所有数字便是题目所求的 最小的 k 个数 。</p>
<p>根据此思路，考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于 k ，若 true 则直接返回此时数组的前 k 个数字即可。</p>
<h3 id="复杂度分析-1">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N)， 因为我们是要找下标为 k 的元素，第一次切分的时候需要遍历整个数组 (0 ~ n) 找到了下标是 j 的元素，假如 k 比 j 小的话，那么我们下次切分只要遍历数组 (0~k-1)的元素，反之如果 k 比 j 大的话，那下次切分只要遍历数组 (k+1～n) 的元素，总之可以看作每次调用 partition 遍历的元素数目都是上一次遍历的 1/2，因此时间复杂度是 N + N/2 + N/4 + &hellip; + N/N = 2N, 因此时间复杂度是 O(N)。</p>
<p><strong>空间复杂度</strong>：O(log N)，划分函数的平均递归深度为 O(log N)。</p>
<h3 id="code-1">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">// 入口
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">getLeastNumbers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 边界条件
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
        <span class="c1">// 递归调用
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// quick_sort() 的功能不是排序整个数组，而是搜索并返回最小的 k 个数.
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="n">j</span><span class="o">--;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="n">i</span><span class="o">++;</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">left</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="23堆">2.3、堆</h2>
<h3 id="核心思路-2">核心思路</h3>
<p>我们用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。</p>
<h3 id="复杂度分析-2">复杂度分析</h3>
<p><strong>时间复杂度</strong>：时间复杂度：O(n log k)，其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 O(log k) 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 O(n log k) 的时间复杂度。</p>
<p><strong>空间复杂度</strong>：O(k)，因为大根堆里最多 k 个数。</p>
<h3 id="code-2">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">getLeastNumbers</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 边界情况
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
        <span class="o">}</span>

        <span class="c1">// 结果
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>

        <span class="c1">// 优先级队列
</span><span class="c1"></span>        <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="c1">// 自定义比较器, 使之成为大顶堆.  默认为大顶堆
</span><span class="c1"></span>            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Integer</span> <span class="n">num1</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">num2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">num2</span> <span class="o">-</span> <span class="n">num1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="c1">// 向优先队列中插入 arr 的前 k 个元素
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// 循环处理剩下的的元素
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果队首元素(也就是队列中权值最大的那个元素)大于当前的值
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="c1">// 删除队首元素
</span><span class="c1"></span>                <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="c1">// 向优先队列中插入当前元素
</span><span class="c1"></span>                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 依次取出优先级队列的元素，构造数据
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/zui-xiao-de-kge-shu-by-leetcode-solution/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/zui-xiao-de-kge-shu-by-leetcode-solution/</a></p>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/</a></p>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/</a></p>
]]></description>
</item><item>
    <title>14、剑指 Offer 20. 表示数值的字符串</title>
    <link>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/14.html</link>
    <pubDate>Wed, 15 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.top/posts/series/leetcode-jianzhioffer-java/14.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 48. 最长不含重复字符的子字符串</a> 难度中等</p>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p><strong>示例 1:</strong></p>
<pre tabindex="0"><code>输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre><p><strong>示例 2:</strong></p>
<pre tabindex="0"><code>输入: &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
</code></pre><p><strong>示例 3:</strong></p>
<pre tabindex="0"><code>输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。
</code></pre><p>提示：</p>
<ul>
<li><code>s.length &lt;= 40000</code></li>
</ul>
<p>注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21滑动窗口法">2.1、滑动窗口法</h2>
<h3 id="核心思路">核心思路：</h3>
<p>记 <code>left = 0</code> 为滑动窗口的左边界下标，<code>right = 0</code>为右边界下标。</p>
<p>借助哈希表，在遍历字符串 s 时，使用哈希表 map 记录各字符最后一次出现的索引位置。</p>
<p>在遍历过程中，不断右移滑动窗口的右下标 <code>right</code>，借助 <code>map</code> 判断 <code>s[right]</code> 字符是否已经遍历过。</p>
<p>根据 <code>s[right]</code> 是否为第一次出现，有以下 2 种情况：</p>
<ul>
<li>是：则 map 中不存在 <code>key = s[right]</code>，此时无需更新左边界 left；</li>
<li>否：则 map 中存在 <code>key = s[right]</code>，取 value ，得到 <code>s[right]</code> 末次出现的下标，记为 index 。更新左边界 left = Math.max ( index + 1, left ) ；</li>
</ul>
<p>更新 <code>s[right]</code> 末次出现的下标，记录滑动窗口的长度最大值 <code>right - left + 1</code> 即可。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N)</p>
<p><strong>空间复杂度</strong>：O(1)，字符的 ASCII 码范围为 00 ~ 127 ，哈希表 map 最多使用 O(128) = O(1) 大小的额外空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 遍历字符串 s 时，使用哈希表 map 统计各字符最后一次出现的索引位置
</span><span class="c1"></span>        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>

        <span class="c1">// left = 滑动窗口的左边界: result = 滑动窗口长度的最大值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="c1">// 遍历字符串 s
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 当前字符
</span><span class="c1"></span>            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>

            <span class="c1">// 如果 map 中存在 key = 当前字符
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 更新滑动窗口的左边界
</span><span class="c1"></span>                <span class="c1">// 左边界只允许向右移
</span><span class="c1"></span>                <span class="n">left</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">left</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// 更新当前字符末次出现的下标
</span><span class="c1"></span>            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">),</span> <span class="n">right</span><span class="o">);</span>

            <span class="c1">// 记录滑动窗口的长度最大值
</span><span class="c1"></span>            <span class="n">result</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/</a></p>
]]></description>
</item></channel>
</rss>
