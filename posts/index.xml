<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - 無糖的小宇宙</title>
        <link>https://sugarless.cn/posts.html</link>
        <description>所有文章 | 無糖的小宇宙</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>jaded@foxmail.com (無糖)</managingEditor>
            <webMaster>jaded@foxmail.com (無糖)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 16 Jan 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://sugarless.cn/posts.html" rel="self" type="application/rss+xml" /><item>
    <title>开篇</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/0.html</link>
    <pubDate>Sun, 15 Aug 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/0.html</guid>
    <description><![CDATA[<h1 id="关于此专栏">关于此专栏</h1>
<p>此专栏内容为 <code>LeetCode 剑指 Offer （第二版）</code> 的 <code>Java</code> 版本题解，我会按照 LeetCode 官方给题目标注的出现频率由高到低排序。</p>
<p>希望能帮助到更多学习算法的朋友们。</p>
<p>解题思路与实现代码来源于官方题解、评论区大佬及网络，非 <code>100%</code> 原创内容，此专栏为我在刷题过程中整理的笔记，仅做收录与整理。</p>
<p>如有侵权，请发送邮件联系我删除相关内容。</p>
]]></description>
</item><item>
    <title>[ 置顶 ] 🚩 Github 项目 / 工具站点 / 有趣的站点</title>
    <link>https://sugarless.cn/posts/mark/1.html</link>
    <pubDate>Tue, 31 Dec 2019 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/mark/1.html</guid>
    <description><![CDATA[<p>内容不定期持续更新，感谢每一位开源项目作者为全世界开发者做出的杰出贡献。本文主要分享一些我平时收集到的一些好物，东西可能比较杂乱。涵盖开源项目、免费的工具站、好用的客户端工具、优秀的付费网站和来路不明的沙雕网站。</p>
<h1 id="github-开源项目">Github 开源项目</h1>
<h2 id="功能性网站">功能性网站</h2>
<h3 id="1兰空图床">1、兰空图床</h3>
<p>使用 thinkphp + mysql 开发，界面简洁易用，支持第三方云储存和远程 FTP 存储。并且有开源的浏览器插件支持。（真香）</p>
<p>官网：<a href="https://www.lsky.pro" target="_blank" rel="noopener noreffer">https://www.lsky.pro</a></p>
<p>GitHub：<a href="https://github.com/wisp-x/lsky-pro" target="_blank" rel="noopener noreffer">https://github.com/wisp-x/lsky-pro</a></p>
<p>浏览器扩展：<a href="https://github.com/wisp-x/lsky-pro-chrome-extension" target="_blank" rel="noopener noreffer">https://github.com/wisp-x/lsky-pro-chrome-extension</a></p>
<h3 id="2基于-phphtml-的轻量级网络测试站点">2、基于 php+html 的轻量级网络测试站点</h3>
<p>HTML5 Speedtest 可用于查看下载速度、ping 速度、上传速度；很小巧方便，直接打开页面点击一下 start 就能自动检测，你本机到远程服务器的网络状况，快速得到观测数据</p>
<p>Github：<a href="https://github.com/librespeed/speedtest" target="_blank" rel="noopener noreffer">https://github.com/librespeed/speedtest</a></p>
<h3 id="3flarum-论坛">3、flarum 论坛</h3>
<p>基于 PHP Laravel 框架构建的一款优雅简洁论坛软件。发帖及跟帖回复使用 markdown 语法是一个亮点。</p>
<p>官网：<a href="https://flarum.org" target="_blank" rel="noopener noreffer">https://flarum.org</a></p>
<p>中文官网：<a href="https://flarum.org.cn" target="_blank" rel="noopener noreffer">https://flarum.org.cn</a></p>
<p>Github：<a href="https://github.com/flarum/flarum" target="_blank" rel="noopener noreffer">https://github.com/flarum/flarum</a></p>
<h2 id="命令行工具">命令行工具</h2>
<h3 id="1annie">1、annie</h3>
<p>基于 Go 开发的一款命令行视频下载器，支持的平台很多，包括 MacOS、Windows、Linux 等。目前支持 bilibili 和 youtube 的播放列表批量下载，其他网站只支持单个视频下载。</p>
<p>Github：<a href="https://github.com/iawia002/annie" target="_blank" rel="noopener noreffer">https://github.com/iawia002/annie</a></p>
<h3 id="2youtube-dl">2、youtube-dl</h3>
<p>下载 youtube 视频的神器
Github：<a href="https://github.com/ytdl-org/youtube-dl" target="_blank" rel="noopener noreffer">https://github.com/ytdl-org/youtube-dl</a>
官网：<a href="http://ytdl-org.github.io/youtube-dl/" target="_blank" rel="noopener noreffer">http://ytdl-org.github.io/youtube-dl/</a></p>
<h2 id="开发工具">开发工具</h2>
<h3 id="1anotherredisdesktopmanager">1、AnotherRedisDesktopManager</h3>
<p>一个 GUI Redis 桌面管理器，兼容 Linux、Windows、Mac。更重要的是，在加载大量的键时，它不会崩溃。</p>
<p>Github：<a href="https://github.com/qishibo/AnotherRedisDesktopManager" target="_blank" rel="noopener noreffer">https://github.com/qishibo/AnotherRedisDesktopManager</a></p>
<h3 id="2switchhosts">2、SwitchHosts</h3>
<p>SwitchHosts 是一个管理、切换多个 hosts 方案的工具。</p>
<p>Github：<a href="https://github.com/oldj/SwitchHosts" target="_blank" rel="noopener noreffer">https://github.com/oldj/SwitchHosts</a></p>
<p>官网：<a href="https://swh.app/zh/" target="_blank" rel="noopener noreffer">https://swh.app/zh/</a></p>
<h3 id="3docsify">3、docsify</h3>
<p>docsify 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 index.html 就可以开始编写文档并直接部署在 GitHub Pages。</p>
<p>Github：<a href="https://github.com/docsifyjs/docsify/" target="_blank" rel="noopener noreffer">https://github.com/docsifyjs/docsify/</a></p>
<p>官网：<a href="https://docsify.js.org/" target="_blank" rel="noopener noreffer">https://docsify.js.org/</a></p>
<h2 id="ui-框架">UI 框架</h2>
<h3 id="1layui">1、LayUI</h3>
<p>对非专业前端的开发人员非常友好，组件丰富，极低门槛，开箱即用。</p>
<p>官网：<a href="https://www.layui.com" target="_blank" rel="noopener noreffer">https://www.layui.com</a></p>
<p>GitHub：<a href="https://github.com/sentsin/layui" target="_blank" rel="noopener noreffer">https://github.com/sentsin/layui</a></p>
<h3 id="2vant-weapp">2、vant-weapp</h3>
<p>有赞出品的开源小程序 UI 组件库</p>
<p>官网：<a href="https://youzan.github.io/vant-weapp" target="_blank" rel="noopener noreffer">https://youzan.github.io/vant-weapp</a></p>
<p>GitHub：<a href="https://github.com/youzan/vant-weapp" target="_blank" rel="noopener noreffer">https://github.com/youzan/vant-weapp</a></p>
<h3 id="3elementui">3、ElementUI</h3>
<p>饿了么开发的基于 Vue 2.0 的桌面端组件库</p>
<p>官网：<a href="https://element.eleme.cn" target="_blank" rel="noopener noreffer">https://element.eleme.cn</a></p>
<h2 id="wordpress-主题">WordPress 主题</h2>
<h3 id="1argon-theme">1、argon-theme</h3>
<p>博客、文章向主题</p>
<p>Github：<a href="https://github.com/solstice23/argon-theme" target="_blank" rel="noopener noreffer">https://github.com/solstice23/argon-theme</a></p>
<p>Demo：<a href="https://solstice23.top/archives/746" target="_blank" rel="noopener noreffer">https://solstice23.top/archives/746</a></p>
<h3 id="2puock">2、Puock</h3>
<p>博客、文章主题</p>
<p>Github：<a href="https://github.com/Licoy/wordpress-theme-puock" target="_blank" rel="noopener noreffer">https://github.com/Licoy/wordpress-theme-puock</a></p>
<p>Demo：<a href="https://www.licoy.cn" target="_blank" rel="noopener noreffer">https://www.licoy.cn</a></p>
<h3 id="3webstack">3、WebStack</h3>
<p>网址导航主题</p>
<p>Github：<a href="https://github.com/owen0o0/WebStack" target="_blank" rel="noopener noreffer">https://github.com/owen0o0/WebStack</a></p>
<h2 id="hugo-主题">Hugo 主题</h2>
<h3 id="1doit">1、DoIt</h3>
<p>个人博客主题</p>
<p>Github：<a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer">https://github.com/HEIGE-PCloud/DoIt</a></p>
<p>Demo：<a href="https://hugodoit.pages.dev/zh-cn/" target="_blank" rel="noopener noreffer">https://hugodoit.pages.dev/zh-cn/</a></p>
<h3 id="2hugo-theme-meme">2、hugo-theme-meme</h3>
<p>个人博客主题</p>
<p>Github：<a href="https://github.com/reuixiy/hugo-theme-meme" target="_blank" rel="noopener noreffer">https://github.com/reuixiy/hugo-theme-meme</a></p>
<p>Demo：<a href="https://io-oi.me/" target="_blank" rel="noopener noreffer">https://io-oi.me/</a></p>
<h2 id="javascript">JavaScript</h2>
<h3 id="1introjs">1、intro.js</h3>
<p>网站页面 / 新功能 引导流程插件</p>
<p>官网：<a href="http://introjs.com" target="_blank" rel="noopener noreffer">http://introjs.com</a></p>
<p>GitHub：<a href="https://github.com/usablica/intro.js" target="_blank" rel="noopener noreffer">https://github.com/usablica/intro.js</a></p>
<h3 id="2clipboardjs">2、clipboard.js</h3>
<p>js 实现一键复制文本到剪贴板插件</p>
<p>官网：<a href="https://clipboardjs.com" target="_blank" rel="noopener noreffer">https://clipboardjs.com</a></p>
<p>GitHub：<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener noreffer">https://github.com/zenorocha/clipboard.js</a></p>
<h3 id="3viewerjs">3、viewer.js</h3>
<p>js 图片浏览插件</p>
<p>官网：<a href="https://fengyuanchen.github.io/viewerjs" target="_blank" rel="noopener noreffer">https://fengyuanchen.github.io/viewerjs</a></p>
<p>Github：<a href="https://github.com/fengyuanchen/viewerjs" target="_blank" rel="noopener noreffer">https://github.com/fengyuanchen/viewerjs</a></p>
<h3 id="4contextjs">4、context.js</h3>
<p>右键菜单插件</p>
<p>官网：<a href="http://lab.jakiestfu.com/contextjs" target="_blank" rel="noopener noreffer">http://lab.jakiestfu.com/contextjs</a></p>
<p>Github：<a href="https://github.com/jakiestfu/Context.js" target="_blank" rel="noopener noreffer">https://github.com/jakiestfu/Context.js</a></p>
<h3 id="5momentjs">5、moment.js</h3>
<p>JavaScript 日期处理类库，多语言支持</p>
<p>官网：<a href="https://momentjs.com" target="_blank" rel="noopener noreffer">https://momentjs.com</a> / <a href="http://momentjs.cn" target="_blank" rel="noopener noreffer">http://momentjs.cn</a></p>
<h3 id="6highlightjs">6、highlight.js</h3>
<p>代码高亮 / 支持 189 种编程语言 / 95 种高亮样式</p>
<p>Github：<a href="https://github.com/highlightjs/highlight.js" target="_blank" rel="noopener noreffer">https://github.com/highlightjs/highlight.js</a></p>
<p>官网：<a href="https://highlightjs.org" target="_blank" rel="noopener noreffer">https://highlightjs.org</a> / <a href="https://highlightjs.org/static/demo" target="_blank" rel="noopener noreffer">https://highlightjs.org/static/demo</a></p>
<h3 id="7pangujs">7、Pangu.js</h3>
<p>中文字和英文、数字、符号之间自动插入空格</p>
<p>Github：<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener noreffer">https://github.com/vinta/pangu.js</a></p>
<p>官网：暂无</p>
<h2 id="m3u-直播源">M3U 直播源</h2>
<h3 id="1wtv">1、wtv</h3>
<p>解决电脑、手机看电视直播的苦恼，收集各种直播源，电视直播网站。建议配合 potplayer 使用。</p>
<p>Github：<a href="https://github.com/biancangming/wtv" target="_blank" rel="noopener noreffer">https://github.com/biancangming/wtv</a></p>
<h2 id="客户端软件">客户端软件</h2>
<h3 id="1contextmenumanager">1、ContextMenuManager</h3>
<p>一个纯粹的 Windows 右键菜单管理程序</p>
<p>Github：<a href="https://github.com/BluePointLilac/ContextMenuManager" target="_blank" rel="noopener noreffer">https://github.com/BluePointLilac/ContextMenuManager</a></p>
<p>官网：<a href="https://bluepointlilac.github.io/ContextMenuManager" target="_blank" rel="noopener noreffer">https://bluepointlilac.github.io/ContextMenuManager</a></p>
<h3 id="2思源笔记">2、思源笔记</h3>
<p>一款本地优先的个人知识管理系统，支持完全离线使用，非常优秀的一款类 notion 应用。</p>
<p>Github：<a href="https://github.com/siyuan-note/siyuan" target="_blank" rel="noopener noreffer">https://github.com/siyuan-note/siyuan</a></p>
<p>官网：<a href="https://b3log.org/siyuan/" target="_blank" rel="noopener noreffer">https://b3log.org/siyuan/</a></p>
<h1 id="工具站点">工具站点</h1>
<h2 id="开发">开发</h2>
<h3 id="1requestcatchercom">1、requestcatcher.com</h3>
<p>Debug web hooks, http clients, etc.</p>
<p>Request Catcher will create a subdomain on which you can test an application. All requests sent to any path on the subdomain are forwarded to your browser in real time.</p>
<p>官网：<a href="https://requestcatcher.com" target="_blank" rel="noopener noreffer">https://requestcatcher.com</a></p>
<h3 id="2jsoncn">2、json.cn</h3>
<p>json 格式化</p>
<p>官网：<a href="http://json.cn" target="_blank" rel="noopener noreffer">http://json.cn</a></p>
<h3 id="3searchcode">3、searchcode</h3>
<p>是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。</p>
<p>官网：<a href="https://searchcode.com" target="_blank" rel="noopener noreffer">https://searchcode.com</a></p>
<p>设计
1、创客贴
付费网站，但提供一些免费资源，比较灵活的在线设计工具。风格比较偏向 MG 动画，可以搞出很花哨的 banner 和长图海报之类的，算是个不错的设计资源网站。</p>
<p>官网：<a href="https://www.chuangkit.com" target="_blank" rel="noopener noreffer">https://www.chuangkit.com</a></p>
<h2 id="书籍">书籍</h2>
<h3 id="1鸠摩搜索">1、鸠摩搜索</h3>
<p>鸠摩是一个电子书搜索引擎，界面简洁、内容纯净，专业而高效。</p>
<p>官网：<a href="https://www.jiumodiary.com" target="_blank" rel="noopener noreffer">https://www.jiumodiary.com</a></p>
<h3 id="2thefuture-书籍搜索">2、thefuture 书籍搜索</h3>
<p>小站，知名度不高，但试着搜索了几本书，感觉还挺好用。</p>
<p>官网：<a href="https://bks.thefuture.top" target="_blank" rel="noopener noreffer">https://bks.thefuture.top</a></p>
<h3 id="3z-library">3、z-library</h3>
<p>可以找到不少英文原版书籍</p>
<p>官网：<a href="https://zh.z-lib.org/" target="_blank" rel="noopener noreffer">https://zh.z-lib.org/</a></p>
<h3 id="4全国图书馆参考咨询联盟">4、全国图书馆参考咨询联盟</h3>
<p>由中国公共、教育、科技系统 图书馆合作建立的公益性服务机构，能找到不少书籍，但下载比较麻烦。</p>
<p>官网：<a href="http://www.ucdrs.superlib.net/" target="_blank" rel="noopener noreffer">http://www.ucdrs.superlib.net/</a></p>
<h2 id="生产力">生产力</h2>
<h3 id="1gitmind-在线思维导图">1、GitMind 在线思维导图</h3>
<p><a href="https://gitmind.cn" target="_blank" rel="noopener noreffer">https://gitmind.cn</a></p>
<h2 id="图像">图像</h2>
<h3 id="1ai-人工智能图片无损放大">1、AI 人工智能图片无损放大</h3>
<p><a href="https://bigjpg.com" target="_blank" rel="noopener noreffer">https://bigjpg.com</a></p>
<h3 id="2tinypng-图片在线压缩">2、tinypng 图片在线压缩</h3>
<p><a href="https://tinypng.com/" target="_blank" rel="noopener noreffer">https://tinypng.com/</a></p>
<h3 id="3squoosh谷歌图片在线压缩--开源">3、Squoosh（谷歌图片在线压缩 / 开源）</h3>
<p><a href="https://squoosh.app/" target="_blank" rel="noopener noreffer">https://squoosh.app/</a></p>
<h3 id="4消除图片中的背景--ai-自动抠图">4、消除图片中的背景 / AI 自动抠图</h3>
<p><a href="https://www.remove.bg/zh" target="_blank" rel="noopener noreffer">https://www.remove.bg/zh</a></p>
<h3 id="5中国哲学书电子化计划">5、中国哲学书电子化计划</h3>
<p>中国哲学书电子化计划是一个线上开放电子图书馆，为中外学者提供中国历代传世文献，力图超越印刷媒体限制，通过电子科技探索新方式与古代文献进行沟通。收藏的文本已超过三万部著作，并有五十亿字之多，故为历代中文文献资料库最大者。</p>
<p><a href="https://ctext.org/zhs" target="_blank" rel="noopener noreffer">https://ctext.org/zhs</a></p>
<h2 id="内容创作">内容创作</h2>
<h3 id="1emoji大全--emoji表情符号词典-">1、Emoji大全 | Emoji表情符号词典 📓</h3>
<p><a href="https://www.emojiall.com/zh-hans" target="_blank" rel="noopener noreffer">https://www.emojiall.com/zh-hans</a></p>
<h3 id="2deepl-翻译">2、DeepL 翻译</h3>
<p><a href="https://www.deepl.com/translator" target="_blank" rel="noopener noreffer">https://www.deepl.com/translator</a></p>
<h2 id="kms">KMS</h2>
<h3 id="1沧水-kms">1、沧水 KMS</h3>
<p><a href="https://kms.cangshui.net" target="_blank" rel="noopener noreffer">https://kms.cangshui.net</a></p>
<h3 id="2moerats-kms">2、moerats KMS</h3>
<p><a href="https://www.moerats.com/kms" target="_blank" rel="noopener noreffer">https://www.moerats.com/kms</a></p>
<h1 id="有趣的站点">有趣的站点</h1>
<ul>
<li>台风路径查询：<a href="http://typhoon.zjwater.gov.cn" target="_blank" rel="noopener noreffer">http://typhoon.zjwater.gov.cn</a></li>
<li>黑客模拟器：<a href="http://geektyper.com" target="_blank" rel="noopener noreffer">http://geektyper.com</a></li>
<li>世界护照大全：<a href="https://www.passportindex.org/cn" target="_blank" rel="noopener noreffer">https://www.passportindex.org/cn</a></li>
<li>查无此人 / AI 生成人脸：<a href="https://thispersondoesnotexist.com" target="_blank" rel="noopener noreffer">https://thispersondoesnotexist.com</a></li>
<li>网页版 windows93：<a href="http://www.windows93.net" target="_blank" rel="noopener noreffer">http://www.windows93.net</a></li>
<li>假装系统在升级：<a href="http://fakeupdate.net" target="_blank" rel="noopener noreffer">http://fakeupdate.net</a></li>
</ul>
<h1 id="其他">其他</h1>
<ul>
<li>中央媒体 &amp; 全国333个地级城市晚报日报 / 电视直播点播：<a href="https://laosheng.top/fly/" target="_blank" rel="noopener noreffer">https://laosheng.top/fly/</a></li>
<li>全历史：<a href="https://www.allhistory.com" target="_blank" rel="noopener noreffer">https://www.allhistory.com</a></li>
<li>西窗烛：<a href="http://lib.xcz.im/library" target="_blank" rel="noopener noreffer">http://lib.xcz.im/library</a></li>
</ul>]]></description>
</item><item>
    <title>1、剑指 Offer 24. 反转链表</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/1.html</link>
    <pubDate>Wed, 18 Aug 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/1.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 24. 反转链表</a> 难度简单</p>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<pre tabindex="0"><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= 节点个数 &lt;= 5000
</code></pre><p><strong>注意</strong>：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21遍历法双指针">2.1、遍历法（双指针）</h2>
<h3 id="核心思想">核心思想：</h3>
<p>在访问各节点时修改其 <code>next</code> 引用指向。在此过程中，可借助辅助变量（指针）来保存当前节点的 next ，以此为基础遍历整个链表。</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<ul>
<li><strong>时间复杂度 O(N)</strong>：遍历链表使用线性大小时间。</li>
<li><strong>空间复杂度 O(1)</strong>： 变量 <code>pre</code> 和 <code>cur</code> 使用常数大小额外空间。</li>
</ul>
<h3 id="代码">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for singly-linked list.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * public class ListNode {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     int val;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode next;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     ListNode(int x) { val = x; }
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 上一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当前节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ListNode</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">cursor</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 辅助变量 next , 用以保存当前节点指向的下一个结点.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 让当前节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cursor</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 循环处理的关键, 让当前节点作为 prev , 让辅助变量 next 作为当节点, 并进入下一个循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">prev</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cursor</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 当 cursor 为 null 时, 整个链表已经被反转过来了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="22递归法">2.2、递归法</h2>
<h3 id="核心思想-1">核心思想：</h3>
<p>使用递归法遍历链表，当越过尾节点后终止递归，在回溯时修改各节点的 <code>next</code> 引用指向。</p>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<ul>
<li><strong>时间复杂度 O(N)</strong>：遍历链表使用线性大小时间。</li>
<li><strong>空间复杂度 O(N)</strong>： 遍历链表的递归深度达到 N ，系统使用 O(N) 大小额外空间。</li>
</ul>
<h3 id="代码-1">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for singly-linked list.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * public class ListNode {
</span></span></span><span class="line"><span class="cl"><span class="cm"> * int val;
</span></span></span><span class="line"><span class="cl"><span class="cm"> * ListNode next;
</span></span></span><span class="line"><span class="cl"><span class="cm"> * ListNode(int x) { val = x; }
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用递归并返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">recur</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">ListNode</span> <span class="nf">recur</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">cur</span><span class="o">,</span> <span class="n">ListNode</span> <span class="n">pre</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当 cur 为 null 时, pre 指向尾结点, 此时将 pre 作为反转链表的表头，开始回溯.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 递归调用函数, 此时将 root 看作是一个已经被反转过的链表的表头.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ListNode</span> <span class="n">root</span> <span class="o">=</span> <span class="n">recur</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 将当前节点的 next 指向上一个节点，也就是 prev
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 将反转过的链表的表头传递返回给上一级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-by-leetcode-solution-jvs5/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-by-leetcode-solution-jvs5/</a></p>
<p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/jian-zhi-offer-24-fan-zhuan-lian-biao-die-dai-di-2/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/jian-zhi-offer-24-fan-zhuan-lian-biao-die-dai-di-2/</a></p>
]]></description>
</item><item>
    <title>2、剑指 Offer 09. 用两个栈实现队列</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/2.html</link>
    <pubDate>Fri, 20 Aug 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/2.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 09. 用两个栈实现队列</a> 难度简单</p>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：
[&#34;CQueue&#34;,&#34;appendTail&#34;,&#34;deleteHead&#34;,&#34;deleteHead&#34;]
[[],[3],[],[]]
输出：[null,null,3,-1]
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：
[&#34;CQueue&#34;,&#34;deleteHead&#34;,&#34;appendTail&#34;,&#34;appendTail&#34;,&#34;deleteHead&#34;,&#34;deleteHead&#34;]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= values &lt;= 10000</code></li>
<li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li>
</ul>
<h1 id="二解法">二、解法</h1>
<h2 id="21双栈法">2.1、双栈法</h2>
<h3 id="核心思想">核心思想：</h3>
<p>维护两个栈，第一个栈（正序支持插入操作，第二个栈支持删除操作。</p>
<p>根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<p>**时间复杂度：**对于插入和删除操作，时间复杂度均为 O(1)。插入不多说，对于删除操作，虽然看起来是 O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 <code>stack2</code> 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)。</p>
<p><strong>空间复杂度：O(n)</strong>。需要使用两个栈存储已有的元素。</p>
<h3 id="代码优化前">代码（优化前）：</h3>
<p>这个是我第一次解题时的写法，因为我是实时维护正序栈与逆序栈的，所以效率比较底下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">CQueue</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 正序栈 A ：队列正序（栈顶元素即为队列头）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stackA</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 逆序栈 B ：队列逆序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stackB</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">CQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 初始化双栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">stackA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">stackB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在队列尾部插入整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">appendTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 压入逆序栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stackB</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 更新正序栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stackA</span> <span class="o">=</span> <span class="n">reverse</span><span class="o">(</span><span class="n">stackB</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在队列头部删除整数 若队列中没有元素，deleteHead 操作返回 -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">deleteHead</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果队列中没有元素,则返回 -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">stackA</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 正序栈的栈顶元素出站
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stackA</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 更新逆序栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stackB</span> <span class="o">=</span> <span class="n">reverse</span><span class="o">(</span><span class="n">stackA</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取一个栈的逆序栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">(</span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;)</span> <span class="n">stack</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(!</span><span class="n">temp</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="代码优化后">代码（优化后）：</h3>
<p>此版本为参考官方题解的解题思路与评论区 kd35 大佬的代码，也是本解法中核心思想的实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">CQueue</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 栈 A ：队列正序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stackA</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 栈 B ：队列逆序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stackB</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">CQueue</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 初始化双栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">stackA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">stackB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在队列尾部插入整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">appendTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 压入逆序栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stackB</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在队列头部删除整数 若队列中没有元素，deleteHead 操作返回 -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">deleteHead</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(!</span><span class="n">stackA</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 正序栈存在元素, 将栈顶元素出栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">stackA</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 更新正序栈：此时正序栈中不存在元素，将逆序栈中的元素依次出栈，并压入正序栈中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="o">(!</span><span class="n">stackB</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">stackA</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">stackB</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果更新后的正序栈依然为空, 则说明队列中此时没有元素, 返回 -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果更新后的正序栈不为空, 则将正序栈的栈顶出栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">stackA</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="o">-</span><span class="n">1</span> <span class="o">:</span> <span class="n">stackA</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/</a></p>
]]></description>
</item><item>
    <title>3、剑指 Offer 03. 数组中重复的数字</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/3.html</link>
    <pubDate>Sun, 22 Aug 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/3.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 03. 数组中重复的数字</a> 难度简单</p>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>2 &lt;= n &lt;= 100000
</code></pre><h1 id="二解法">二、解法</h1>
<h2 id="21hashset-遍历法">2.1、HashSet 遍历法</h2>
<h3 id="核心思想">核心思想：</h3>
<p>在遍历过程中使用 HashSet 存储已经遇到的数字，如果遇到的一个数字已经在 HashSet 中，则当前的数字是重复数字。</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<ul>
<li>
<p><strong>时间复杂度：O(n)</strong>：遍历数组一遍。使用哈希集合（<code>HashSet</code>），添加元素的时间复杂度为 O(1)<em>O</em>(1)，故总的时间复杂度是 O(n)<em>O</em>(<em>n</em>)。</p>
</li>
<li>
<p><strong>空间复杂度：O(n)</strong>：不重复的每个元素都可能存入集合，因此占用 O(n)<em>O</em>(<em>n</em>) 额外空间。</p>
</li>
</ul>
<h3 id="代码">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// HashSet 法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findRepeatNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">repeatNumber</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">repeatNumber</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">repeatNumber</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="22交换法">2.2、交换法</h2>
<h3 id="核心思想-1">核心思想：</h3>
<p>题目规定：在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。</p>
<p>说明数组元素的 <strong>索引</strong> 和 <strong>值</strong> 是 <strong>一对多</strong> 的关系。</p>
<p>因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（ 即 nums[ i ] = i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p>
<p>遍历中，第一次遇到数字 xx 时，将其交换至索引 xx 处；而当第二次遇到数字 xx 时，一定有 nums[x] = x ，此时即可得到一组重复数字。</p>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<ul>
<li><strong>时间复杂度 O(N)</strong>： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。</li>
<li><strong>空间复杂度 O(1)</strong>： 使用常数复杂度的额外空间。</li>
</ul>
<h3 id="代码-1">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 原地交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findRepeatNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">i</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
</span></span><span class="line"><span class="cl">            <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-b-4/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-b-4/</a></p>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/</a></p>
]]></description>
</item><item>
    <title>4、剑指 Offer 51. 数组中的逆序对</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/4.html</link>
    <pubDate>Tue, 24 Aug 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/4.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 51. 数组中的逆序对</a> 难度困难</p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p><strong>示例 1:</strong></p>
<pre tabindex="0"><code>输入: [7,5,6,4]
输出: 5
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>0 &lt;= 数组长度 &lt;= 50000
</code></pre><h1 id="二解法">二、解法</h1>
<h2 id="21归并排序统计法">2.1、归并排序统计法</h2>
<h3 id="核心思路">核心思路：</h3>
<p>求逆序对和归并排序有什么关系呢？关键就在于「归并」当中「并」的过程。</p>
<p>归并排序体现了 “分而治之” 的算法思想，具体为：</p>
<ul>
<li><strong>分：</strong> 不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转化为子数组的排序问题；</li>
<li><strong>治：</strong> 划分到子数组长度为 1 时，开始向上合并，不断将 <strong>较短排序数组</strong> 合并为 <strong>较长排序数组</strong>，直至合并至原数组时完成排序；</li>
</ul>
<p><strong>合并阶段</strong> 本质上是 <strong>合并两个排序数组</strong> 的过程，而每当遇到 左子数组当前元素 &gt; 右子数组当前元素 时，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」 。</p>
<p>举个例子来说明：假设我们有两个已排序的序列等待合并，分别是 L = { 8, 12, 16, 22, 100 } 和 R = { 9, 26, 55, 64, 91 } 。一开始我们用指针 <code>i = 0</code> 指向 L 的首部，<code>j = 0</code> 指向 R 的头部。记已经合并好的部分为 M 。</p>
<pre tabindex="0"><code>L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = []
     |                          |
     i                          j
</code></pre><p>我们发现 <code>i</code> 指向的元素小于 <code>j</code> 指向的元素，于是把 <code>i</code> 指向的元素放入答案，并把 <code>i</code> 后移一位。这个时候我们把左边的 8 加入了答案，此时右边没有数比 8 小。</p>
<pre tabindex="0"><code>L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = [8]
        |                       |
        i                       j
</code></pre><p>接着我们继续合并，此时<code>i</code>指向的元素（12）大于<code>j</code>指向的元素（9），那么我们可知<code>i</code>后面的元素也大于 9 ，也就是 12/16/22/100 都大于 9 ，由此我们就得到了 4 对逆序对。</p>
<p>然后把 9 加入答案，此时 <code>i</code> 指向 12，<code>j</code> 指向 26 。</p>
<pre tabindex="0"><code>L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = [8, 9]
        |                          |
        i                          j
</code></pre><p>以此类推，等合并完这两个已排序的序列后，我们就算出了本轮的逆序对数量。</p>
<p>因此，本题的关键是使用归并排序中的合并阶段来统计逆序对数量的。</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<ul>
<li><strong>时间复杂度 O(N * log N)：</strong> 其中 N 为数组长度；归并排序使用 O(N * log N) 时间；</li>
<li><strong>空间复杂度 O(N)*O*(*N*) ：</strong> 辅助数组 tmp 占用 O(N) 大小的额外空间；</li>
</ul>
<h3 id="代码">代码：</h3>
<p>为简化代码，「 当 j = r + 1 时 」 与 「 当 tmp[ i ] &lt;= tmp[ j ] 时 」 两判断项可合并。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="n">tmp</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">reversePairs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 终止条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="o">)</span> <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 递归划分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">)</span> <span class="o">+</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 合并阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 left~right 区间的值拷贝到 tmp 数组的对应区间中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 根据 tmp 中对应区间的值操作 nums 数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// i 已经走到尽头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">right</span> <span class="o">+</span> <span class="n">1</span> <span class="o">||</span> <span class="n">tmp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">tmp</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// j 已经走到尽头 || j 位置的值比 i 位置的值大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// i 位置的值比 j 位置的值大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 统计逆序对（ 推论：i~mid 位置的数都比 j 位置的数大，因此此次统计到的逆序对数量为 mid-i+1 ）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">result</span> <span class="o">+=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="ref">REF</h1>
<p>官方题解：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</p>
<p>评论区题解：</p>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-pvn2h/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-pvn2h/</a></p>
]]></description>
</item><item>
    <title>5、剑指 Offer 42. 连续子数组的最大和</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/5.html</link>
    <pubDate>Thu, 26 Aug 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/5.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 42. 连续子数组的最大和</a> 难度简单</p>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p><strong>示例1:</strong></p>
<pre tabindex="0"><code>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-100 &lt;= arr[i] &lt;= 100</code></li>
</ul>
<p>注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21动态规划">2.1、动态规划</h2>
<h3 id="核心思路">核心思路</h3>
<p><strong>状态定义</strong>：设动态规划列表 dp ，dp[i] 代表以元素 nums[i] 为结尾的连续子数组最大和。</p>
<ul>
<li>为何定义最大和 dp[i] 中必须包含元素 nums[i] ：保证 dp[i] 递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的 连续子数组 要求。</li>
</ul>
<p><strong>转移方程</strong>： 若 dp[i−1]≤0 ，说明 dp[i - 1] 对 dp[i] 产生负贡献，即 dp[i-1] + nums[i] 还不如 nums[i] 本身大。</p>
<ul>
<li>当 dp[i - 1] &gt; 0 时：执行 dp[i] = dp[i-1] + nums[i] ；</li>
<li>当 dp[i - 1]≤0 时：执行 dp[i] = nums[i] ；</li>
</ul>
<p><strong>初始状态</strong>： dp[0] = nums[0]，即以 nums[0] 结尾的连续子数组最大和为 nums[0] 。</p>
<p><strong>返回值</strong>： 返回 dp 列表中的最大值，代表全局最大值。</p>
<!-- raw HTML omitted -->
<a class="lightgallery" href="/post_images/image-20211007095730456.png" title="/post_images/image-20211007095730456.png" data-thumbnail="/post_images/image-20211007095730456.png">
        
    </a>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(N)，线性遍历数组 nums 即可获得结果，使用 O(N) 时间。</p>
<p><strong>空间复杂度</strong>：O(1)，使用常数大小的额外空间。</p>
<h3 id="code">Code</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 nums 的首个元素作为初始最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 记录 dp[i-1] 的值，对于dp[0]而言，其前面的dp[-1]=0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">former</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 记录 dp[i] 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">former</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="n">cur</span> <span class="o">+=</span> <span class="n">former</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="n">max</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">former</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</a></p>
]]></description>
</item><item>
    <title>6、剑指 Offer 38. 字符串的排列</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/6.html</link>
    <pubDate>Sat, 28 Aug 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/6.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 38. 字符串的排列</a></p>
<p>难度中等403收藏分享切换为英文接收动态反馈</p>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p><strong>示例:</strong></p>
<pre tabindex="0"><code>输入：s = &#34;abc&#34;
输出：[&#34;abc&#34;,&#34;acb&#34;,&#34;bac&#34;,&#34;bca&#34;,&#34;cab&#34;,&#34;cba&#34;]
</code></pre><p><strong>限制：</strong></p>
<pre tabindex="0"><code>1 &lt;= s 的长度 &lt;= 8
</code></pre><h1 id="二解法">二、解法</h1>
<h2 id="21回溯---dfs--剪枝">2.1、回溯  / DFS + 剪枝</h2>
<h3 id="核心思想">核心思想：</h3>
<p>我们将这个问题看作有 n 个排列成一行的空位，我们需要从左往右依次填入题目给定的 n 个字符，每个字符只能使用一次。首先可以想到穷举的算法，即从左往右每一个空位都依次尝试填入一个字符，看是否能填完这 n 个空位，编程实现时，我们可以用「回溯法」来模拟这个过程，也就是 DFS 。</p>
<p>按照题目中给定的要求，生成字符串的所有排列之后，里面不能有重复元素，也就是说我们需要按照这个规则来进行剪枝，减少不必要的运算。</p>
<p>对于一个长度为 n 的字符串（假设字符互不重复），其排列方案数共有：n×(n−1)×(n−2)…×2×1</p>
<p><strong>排列方案的生成：</strong></p>
<p>通过字符交换，先固定第 1 位字符（ n 种情况）、再固定第 2 位字符（ n-1 种情况）、&hellip; 、最后固定第 n 位字符（ 1 种情况）。</p>
<p></p>
<p><strong>重复排列方案与剪枝：</strong></p>
<p>当字符串存在重复字符时，排列方案中也存在重复的排列方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p>
<p></p>
<p><strong>递归解析：</strong></p>
<ul>
<li>终止条件： 当 x = len(chars) - 1 时，代表所有位已固定（最后一位只有 11 种情况），则将当前组合 chars 转化为字符串并加入 result ，并返回；</li>
<li>递推参数： 当前固定位 x ；</li>
<li>递推工作： 初始化一个 Set ，用于排除重复的字符；将第 x 位字符与 i ∈ [ x, len(chars) ] 字符分别交换，并进入下层递归；
<ul>
<li>剪枝： 若 chars[i] 在 Set 中，代表其是重复字符，因此 “剪枝” ；</li>
<li>将 chars[i] 加入 Set ，以便之后遇到重复字符时剪枝；</li>
<li>固定字符： 将字符 chars[i] 和 chars<i class="far fa-check-square fa-fw"></i> 交换，即固定 chars[i] 为当前位字符；</li>
<li>开启下层递归： 调用 dfs(x + 1) ，即开始固定第 x + 1 个字符；</li>
<li>还原交换： 将字符 chars[i] 和 chars<i class="far fa-check-square fa-fw"></i> 交换（还原之前的交换）；</li>
</ul>
</li>
</ul>
<h3 id="复杂度分析">复杂度分析：</h3>
<ul>
<li>时间复杂度 O(N!N)： N 为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 N×(N−1)×(N−2)…×2×1 ，即复杂度为 O(N!) ；字符串拼接操作 join() 使用 O(N) ；因此总体时间复杂度为 O(N! × N) 。</li>
<li>空间复杂度 O(N^2) ： 全排列的递归深度为 N ，系统累计使用栈空间大小为 O(N)；递归中辅助 Set 累计存储的字符数量最多为 N+(N−1)+&hellip;+2+1=(N+1)N/2 ，即占用 O(N^2) 的额外空间。</li>
</ul>
<h3 id="代码">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 回溯法 / dfs + 剪枝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span><span class="o">[]</span> <span class="nf">permutation</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">chars</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">chars</span><span class="o">));</span>      <span class="c1">// 添加排列方案
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 重复，因此剪枝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">swap</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>                      <span class="c1">// 交换，将 c[i] 固定在第 x 位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">dfs</span><span class="o">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>                      <span class="c1">// 开启固定第 x + 1 位字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">swap</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>                      <span class="c1">// 恢复交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">a</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">chars</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">b</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">chars</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="22下一个排列">2.2、下一个排列</h2>
<h3 id="核心思想-1">核心思想：</h3>
<p>我们可以这样思考：当我们已知了当前的一个排列，我们能不能快速得到字典序中下一个更大的排列呢？</p>
<p>答案是肯定的，参见「31. 下一个排列的官方题解」，当我们已知了当前的一个排列，我们可以在 O(n)O(n) 的时间内计算出字典序下一个中更大的排列。这与 C++ 中的 next_permutation 函数功能相同。</p>
<p>具体地，我们首先对给定的字符串中的字符进行排序，即可得到当前字符串的第一个排列，然后我们不断地计算当前字符串的字典序中下一个更大的排列，直到不存在更大的排列为止即可。</p>
<p>这个方案的优秀之处在于，我们得到的所有排列都不可能重复，这样我们就无需进行去重的操作。同时因为无需使用回溯法，没有栈的开销，算法时间复杂度的常数较小。</p>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<p>**时间复杂度：**O(n×n!)，其中 n 为给定字符串的长度。我们需要 O(nlogn) 的时间得到第一个排列，nextPermutation 函数的时间复杂度为 O(n)，我们至多执行该函数 O(n!) 次，因此总时间复杂度为 O(n×n!+nlogn)=O(n×n!)。</p>
<p>**空间复杂度：**O(1)，注意返回值不计入空间复杂度。</p>
<h3 id="代码-1">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span><span class="o">[]</span> <span class="nf">permutation</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 存储所有排列的变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// string 转换为 char 数组，对其排序        
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 循环计算下一个更大的排列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">do</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">nextPermutation</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 构造符合题目要求的数据格式 -&gt; String 数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span><span class="o">[]</span> <span class="n">retArr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">retArr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">retArr</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 求下一个更大的排列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">nextPermutation</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// i 从 arr 的倒数第二个位置开始向前找，直到符合 arr[i] &lt; arr[i + 1] 为止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// j 从 arr 的最后一个位置开始找，直到符合 arr[i] &lt; arr[j] 为止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 交换 arr[i] 和 arr[j] 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 arr 中下标从 i+1 开始，直到 arr 的末尾的元素反转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">reverse</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 交换 char 数组下标为 i 和 j 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 反转 char 数组的部分元素, 下标从 start 开始到末尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">start</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="三解法补充说明">三、解法补充说明</h1>
<h2 id="dfs--剪枝">DFS + 剪枝</h2>
<p>以 DFS+剪枝 这个解法来说，实际上你可以把问题分解为两个：</p>
<ul>
<li>如何列出字符串的全排列？</li>
<li>如何对全排列去重？</li>
</ul>
<p>我们使用 DFS 生成全排列，并且在生成的过程中剪枝，提高计算效率。</p>
<p><strong>DFS 生成全排列</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;1233&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Solution</span> <span class="n">solution</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Solution</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">solution</span><span class="o">.</span><span class="na">permutation</span><span class="o">(</span><span class="n">str</span><span class="o">)));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 示范如何使用 dfs 穷举字符串排列（不去重/剪枝）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span><span class="o">[]</span> <span class="nf">permutation</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">chars</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">chars</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">swap</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs</span><span class="o">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">swap</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">a</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">chars</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">b</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">chars</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>此时在这个基础上进行改造，做剪枝处理，也就得到了最终的答案。</p>
<h2 id="下一个排列">下一个排列</h2>
<p>先给字符串进行排序，就可以得到第一个排列，然后我们不断地计算当前字符串的字典序中下一个更大的排列，直到不存在更大的排列为止即可。</p>
<p>这个方案的优秀之处在于，我们得到的所有排列都不可能重复，这样我们就无需进行去重的操作。同时因为无需使用回溯法，没有栈的开销，算法时间复杂度的常数较小。</p>
<h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/zi-fu-chuan-de-pai-lie-by-leetcode-solut-hhvs/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/zi-fu-chuan-de-pai-lie-by-leetcode-solut-hhvs/</a></p>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/</a></p>
]]></description>
</item><item>
    <title>7、剑指 Offer 22. 链表中倒数第k个节点</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/7.html</link>
    <pubDate>Sun, 29 Aug 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/7.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 22. 链表中倒数第k个节点</a> 难度简单</p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>
<p><strong>示例：</strong></p>
<pre tabindex="0"><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.

返回链表 4-&gt;5.
</code></pre><h1 id="二解法">二、解法</h1>
<h2 id="21双指针二次遍历">2.1、双指针二次遍历</h2>
<h3 id="核心思路">核心思路：</h3>
<ol>
<li>先遍历统计链表长度，记为 count ；</li>
<li>设置一个指针走 (n-k) 步，即可找到链表倒数第 k 个节点。</li>
</ol>
<p>这也是最容易想到的解法</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<p>时间复杂度 O(N) ： 需要两次遍历，因此至多为 2N 。
空间复杂度 O(1) ： 需要一个辅助指针，使用常数大小的额外空间。</p>
<h3 id="代码">代码：</h3>
<p>需要注意的是，此解法没有考虑以下几种特殊情况。</p>
<ol>
<li>head为空指针；</li>
<li>k大于链表的长度；</li>
<li>输入的参数k为0；</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">getKthFromEnd</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 第一次遍历链表,计算总节点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">cursor</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">count</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cursor</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 第二次遍历链表,找到倒数第k个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">index</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="22双指针单次遍历">2.2、双指针单次遍历</h2>
<h3 id="核心思路-1">核心思路：</h3>
<p>不需要知道链表长度，指针 1 先走 k-1 步，然后指针 2 和指针 1 同时前进，当指针 1 指向链表最后一个元素时，指针 2 即为所求。</p>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<p>时间复杂度 O(N) ： N 为链表长度；总体看， 指针 1 走了 N 步， 指针 走了 (N-k)(N−k) 步。
空间复杂度 O(1)： 双指针 former , latter 使用常数大小的额外空间。</p>
<h3 id="代码-1">代码：</h3>
<p>需要注意的是，此解法没有考虑以下几种特殊情况。</p>
<ol>
<li>head为空指针；</li>
<li>k大于链表的长度；</li>
<li>输入的参数k为0；</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">getKthFromEnd</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="n">former</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">latter</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 让指针 1 先走 k 步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
</span></span><span class="line"><span class="cl">            <span class="n">former</span> <span class="o">=</span> <span class="n">former</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 让指针1 和指针 2 同步移动, 待指针 2 走至链表尾结点时, 指针 1 指向的结点就是符合题意的答案
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">former</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">former</span> <span class="o">=</span> <span class="n">former</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">latter</span> <span class="o">=</span> <span class="n">latter</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">latter</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/mian-shi-ti-22-lian-biao-zhong-dao-shu-di-kge-j-11/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/mian-shi-ti-22-lian-biao-zhong-dao-shu-di-kge-j-11/</a></p>
]]></description>
</item><item>
    <title>8、剑指 Offer 11. 旋转数组的最小数字</title>
    <link>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/8.html</link>
    <pubDate>Wed, 01 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>無糖</name>
    </author><guid>https://sugarless.cn/posts/series/leetcode-jianzhioffer-java/8.html</guid>
    <description><![CDATA[<h1 id="一题目">一、题目</h1>
<p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener noreffer">剑指 Offer 11. 旋转数组的最小数字</a> 难度简单</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：[3,4,5,1,2]
输出：1
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：[2,2,2,0,1]
输出：0
</code></pre><p>注意：本题与主站 154 题相同：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/</p>
<h1 id="二解法">二、解法</h1>
<h2 id="21遍历求最小值不推荐">2.1、遍历求最小值（不推荐）</h2>
<h3 id="核心思想">核心思想：</h3>
<p>遍历数组，求最小值。</p>
<h3 id="复杂度分析">复杂度分析：</h3>
<p><strong>时间复杂度</strong>：O(N) 。</p>
<p><strong>空间复杂度</strong>：O(1)。min 变量使用常数大小的额外空间。</p>
<h3 id="代码">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">min</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">min</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="22二分法推荐">2.2、二分法（推荐）</h2>
<h3 id="核心思想-1">核心思想：</h3>
<p>排序数组的查找问题首先考虑使用 <strong>二分法</strong> 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。</p>
<p>寻找旋转数组的最小元素即为寻找 <strong>右排序数组</strong> 的首个元素 nums[ x ] ，称 x 为 旋转点。</p>
<ul>
<li>右排序数组：在 [ 3, 4, 5, 1, 2 ] 序列中，我们将 [ 1, 2 ] 称为右排序数组；</li>
<li>旋转点：在 [ 3, 4, 5, 1, 2 ] 序列中，我们将右排序数组的首个元素称为旋转点；</li>
</ul>
<h3 id="复杂度分析-1">复杂度分析：</h3>
<p><strong>时间复杂度：</strong> O(log₂N) 。在特例情况下（例如 [ 1,1,1,1 ]），会退化到 O(N)。</p>
<p><strong>空间复杂度：</strong> O(1)。i， j，mid 变量使用常数大小的额外空间。</p>
<h3 id="代码-1">代码：</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">numbers</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 旋转点 x (最小值)一定在 [mid+1,j] 闭区间内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">i</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 旋转点 x (最小值)一定在 [i,mid] 闭区间内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 旋转点在 [i,j-1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">j</span><span class="o">--;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="ref">REF</h1>
<p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></p>
]]></description>
</item></channel>
</rss>
