[{"categories":["折腾"],"content":"尽量简化不必要的流程，保持最简洁的操作，只需一条命令即可完成 hugo 静态 html 渲染、提交到 github 等一系列操作。 本操作只在 windows 平台下实践过，其他平台可自行尝试。 先安装 git bash：https://git-scm.com/downloads 确定hugo 博客的根目录：public 的上级目录就是你博客的根目录，我的根目录是 D:\\blog\\src D:\\BLOG\\SRC │ config.toml ├─archetypes ├─assets ├─content ├─data ├─layouts ├─public ├─resources ├─static └─themes 将 git 仓库（xxx.github.io）的 .git 文件夹和 CNAME 文件复制一份到博客根目录的 public 文件夹中，使 public 目录成为一个仓库。 配置 git alias 别名，这里我将 git blog 这个命令作为以后日常一键部署的命令，注意，此处的博客根目录不要填写错误。 git config --global alias.blog '!cd D:\\\\blog\\\\src;hugo;cd D:\\\\blog\\\\src\\\\public;git add .;git commit -m 'update';git push' 以后写好文章之后，就可以在任意目录执行这个命令： git blog 即可一键渲染、并提交推送到 github 上了，配合 git pages 使用更佳。 ","date":"2021-07-14","objectID":"/2021/07/14/hugo-%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/:0:0","series":null,"tags":["hugo"],"title":"hugo 一键部署","uri":"/2021/07/14/hugo-%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/"},{"categories":[],"content":"WizeTree 是一款 Windows 平台下的磁盘空间分析器。 通过可视化（图形化、树形化）的布局，你可以直观地看到在你硬盘上大的文件和文件夹。 内置文件管理器，支持查看文件树、文件夹大小排序、文件类型分析 wiztree 使用 NTFS 文件系统的 MFT 进行文件分析 (与著名的软件 everything 原理相同) 比 spacesniffer 的速度快数十倍，几秒钟就能完成全盘文件大小分析。 官网：https://www.diskanalyzer.com/ 预览图 ","date":"2021-07-14","objectID":"/2021/07/14/wiztree-%E6%9C%80%E5%BF%AB%E7%9A%84%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E5%99%A8/:0:0","series":null,"tags":["软件"],"title":"WizTree - 最快的磁盘空间分析器","uri":"/2021/07/14/wiztree-%E6%9C%80%E5%BF%AB%E7%9A%84%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%86%E6%9E%90%E5%99%A8/"},{"categories":null,"content":"一个 Php 转 Java 的后端工程师。 Email jaded@foxmail.com ","date":"2021-07-13","objectID":"/about/:0:0","series":null,"tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"CrownDaisy said, Less is more. xiaoz said, 生命不息，吾将折腾不止。 ","date":"2021-07-13","objectID":"/friends/:0:0","series":null,"tags":null,"title":"友链 / 朋友们","uri":"/friends/"},{"categories":["折腾"],"content":"有些网页上的视频是分成多个 ts 片段的，无法被 chrome的 各种嗅探器插件捕获，但通过 F12 开发工具监测网络（Network）时，在过滤器中输入 m3u8，可以发现一个独立的 m3u8 文件，这个文件就是记录了所有 ts 文件片段的一个播放列表。 文件内容大致像这样： 如果没有发现独立的 m3u8 文件，有可能每一个 ts 文件的地址中也是含有这个 m3u8 文件的名称的。把这个 m3u8 文件的完整地址截取出来。针对这种情况，我就不具体举例了，因为我还没遇到过。 到 header tab 里，复制一下这个 m3u8 文件的完整 url ，画红线的这部分就是。 假设这个地址是：https://xxx.abc.com/xxx/a.m3u8 可以使用ffmpeg（FFmpeg）命令下载合并输出为一个视频文件 ffmpeg -i https://xxx.abc.com/xxx/a.m3u8 -c copy output.mp4 ","date":"2021-07-13","objectID":"/2021/07/13/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD-ts-%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91/:0:0","series":null,"tags":["流媒体","FFmpeg"],"title":"如何下载 ts 流媒体视频","uri":"/2021/07/13/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD-ts-%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91/"},{"categories":["Python"],"content":"问题：有些批量下载的视频会带固定前缀，在视频播放器的播放列表里显示非常不友好。 场景：在 “D:\\纪录片\\中国通史” 路径下有 100 集视频文件，每个文件都带有固定前缀 “www.baidu.com 出品 微信公众号 xxx” 字样。 源码 RemoveFixedPrefix.py ，因为源码使用了 python fstring 的特性，需要在 python \u003e= 3.6 的版本中使用。 # coding=utf-8 import os # 目标路径 srcPath = \"D:\\纪录片\\中国通史\" fileList = os.listdir(srcPath) # 固定前缀 FixedPrefix = \"www.baidu.com出品 微信公众号xxx\" for fileName in fileList: oldFilePath = f\"{srcPath}/{fileName}\" # 跳过目录 if os.path.isdir(oldFilePath): continue newFileName = fileName.replace(FixedPrefix, \"\") newFilePath = f\"{srcPath}/{newFileName}\" try: os.rename(oldFilePath, newFilePath) except Exception as e: print(e) print(newFileName) ","date":"2021-06-21","objectID":"/2021/06/21/python-%E6%89%B9%E9%87%8F%E5%8E%BB%E9%99%A4%E6%96%87%E4%BB%B6%E5%9B%BA%E5%AE%9A%E5%89%8D%E7%BC%80/:0:0","series":null,"tags":[],"title":"Python 批量去除文件固定前缀","uri":"/2021/06/21/python-%E6%89%B9%E9%87%8F%E5%8E%BB%E9%99%A4%E6%96%87%E4%BB%B6%E5%9B%BA%E5%AE%9A%E5%89%8D%E7%BC%80/"},{"categories":["PHP"],"content":"结论推导 一、结论 # 最方便 echo strtotime('23:59:59') - time(); #最快 echo 86400 - (time() + 28800) % 86400; 二、推导过程 用 86400 减去今天已经过去了多少秒，即可求得今天还剩多少秒。 86400=24*3600，即一天的总秒数。 28800=8*3600，即 8 个小时的总秒数。 当前时间戳取模 86400 并不是今天已经过去了多少秒，因为时间戳起始时间并不是 0 点，而是 8 点整。所以，如果当前是早上 8 点整，取模 86400 后会等于 0，与我们的本意不符（求今天已经过去了多少秒）。 因此，要用当前时间戳加上 8 个小时的总秒数后再取模 86400，即可求得今天过去了多少秒。 结论是由下面的算法简化后得到的： 86400 - (time() + 8 * 3600) % 86400 三、REF https://segmentfault.com/a/1190000019844608 ","date":"2021-01-12","objectID":"/2021/01/12/php-%E8%AE%A1%E7%AE%97%E5%BD%93%E5%A4%A9%E5%89%A9%E4%BD%99%E7%A7%92%E6%95%B0%E6%9C%80%E6%96%B9%E4%BE%BF%E5%92%8C%E6%9C%80%E5%BF%AB%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":[],"title":"PHP计算当天剩余秒数最方便和最快的方法","uri":"/2021/01/12/php-%E8%AE%A1%E7%AE%97%E5%BD%93%E5%A4%A9%E5%89%A9%E4%BD%99%E7%A7%92%E6%95%B0%E6%9C%80%E6%96%B9%E4%BE%BF%E5%92%8C%E6%9C%80%E5%BF%AB%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["python"],"content":"此前写过一篇基于 BeautifulSoup 库开发的 demo，这次用 xpath 写。 源码 # -*- coding:utf-8 -*- # import requests from lxml import etree def get_headers(): headers = {} headers[\"content-type\"] = \"text/html;\" headers[ \"user-agent\"] = \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36\" headers[\"host\"] = \"top.baidu.com\" return headers url = 'http://top.baidu.com/buzz?b=1' response = requests.get(url, headers=get_headers()) response.encoding = 'gbk' html = response.text if response.status_code != 200: print(f'返回状态码：{response.status_code}') exit(0) # 调用HTML类进行初始化 html = etree.HTML(html) # 提取该页面所有标题 result_all = html.xpath('//*[@id=\"main\"]/div[2]/div/table/tr/td[2]/a[1]') # 打印所有提取出的新闻标题 for v in result_all: print(v.text) 在开发时遇到一个有意思的坑，如果你测试时使用浏览器复制的热点标题的 title xpath，你会发现获取不到标题。你只需要把 tbody 标签去掉，就可以正常获取到标题了。 输出 31省新增本土病例85例:河北82例 佩洛西:众议院将第二次弹劾特朗普 河北新增49例本地无症状感染者 金正恩被推举为朝鲜劳动党总书记 北京新增1例确诊 4例无症状感染者 百度宣布组建智能汽车公司 美发生连环枪击案 一留学生身亡 日本发现新型变异新冠病毒 死刑!曾春亮案一审宣判 青藏高原云南等地降温雨雪来了 拼多多回应员工匿名发帖被辞退 石家庄新增确诊曾去过武汉汉正街 吉林新增4例本土无症状:2对夫妻 袁咏仪 送包给我是张智霖的福分 宋小女:这个结局也挺好 2020年CPI较上年上涨2.5% 全棉时代道歉疑似打广告 韩媒:韩军发现朝鲜举行阅兵式迹象 国会骚乱后特朗普没联系过彭斯 天津处罚过马路的低头族 被放生秃鹫赖警局每天伙食费150 比特币暴跌超10% 20岁小姐姐当汽车兵驰骋川藏线 北京乘出租车网约车需扫健康宝 网上买菜莫名被开通美团月付 自低风险区返乡要检测?多地出通知 车厘子价格腰斩 山东长岛海边现冰冻奇观似鸳鸯锅 武汉向石家庄捐赠50吨蔬菜 康辉说和21岁最大差别是脸的宽度 REF https://blog.csdn.net/qq_36523839/article/details/79992002 ","date":"2021-01-11","objectID":"/2021/01/11/python-%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E5%AE%9E%E6%97%B6%E7%83%AD%E7%82%B9/:0:0","series":null,"tags":[],"title":"Python 爬取百度实时热点","uri":"/2021/01/11/python-%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E5%AE%9E%E6%97%B6%E7%83%AD%E7%82%B9/"},{"categories":["Linux"],"content":"在高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量 socket 处于 TIME_WAIT 状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。 高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个 0~65535 的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。 在这个场景中，短连接表示 “业务处理 + 传输数据的时间 远远小于 TIMEWAIT 超时的时间” 的连接。Linux 默认的 TIME_WAIT 时长一般是 60 秒。 查看默认 timewait 时长 cat /proc/sys/net/ipv4/tcp_fin_timeout 查看连接状态统计 netstat -an | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' 优化内核参数 vim /etc/sysctl.conf #追加内容 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_fin_timeout = 30 释义 开启 SYN Cookies。当出现 SYN 等待队列溢出时，启用 cookies 来处理，可防范少量 SYN 攻击，默认为 0，表示关闭。 net.ipv4.tcp_syncookies = 1 开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接，默认为 0，表示关闭。 net.ipv4.tcp_tw_reuse = 1 开启 TCP 连接中 TIME-WAIT sockets 的快速回收，默认为 0，表示关闭。 net.ipv4.tcp_tw_recycle = 1 修改系統默认的 TIMEOUT 时间（FIN_WAIT_2 状态的时长） net.ipv4.tcp_fin_timeout REF https://www.cnblogs.com/apanly/p/12431902.html https://zhuanlan.zhihu.com/p/79507132 ","date":"2021-01-03","objectID":"/2021/01/03/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-time_wait-%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9E%E6%8E%A5/:0:0","series":null,"tags":[],"title":"Linux服务器出现大量TIME_WAIT状态的连接","uri":"/2021/01/03/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-time_wait-%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9E%E6%8E%A5/"},{"categories":["PHP"],"content":"无限级分类树生成可以使用递归或引用实现，但递归效率太慢，使用引用特性实现会是一个更好的方式。 源码 public function test() { // 初始数据 $items = array( array('id' =\u003e 1, 'pid' =\u003e 0, 'name' =\u003e '福建省'), array('id' =\u003e 2, 'pid' =\u003e 0, 'name' =\u003e '四川省'), array('id' =\u003e 3, 'pid' =\u003e 1, 'name' =\u003e '福州市'), array('id' =\u003e 4, 'pid' =\u003e 2, 'name' =\u003e '成都市'), array('id' =\u003e 5, 'pid' =\u003e 2, 'name' =\u003e '乐山市'), array('id' =\u003e 6, 'pid' =\u003e 4, 'name' =\u003e '成华区'), array('id' =\u003e 7, 'pid' =\u003e 4, 'name' =\u003e '龙泉驿区'), array('id' =\u003e 8, 'pid' =\u003e 6, 'name' =\u003e '崔家店路'), array('id' =\u003e 9, 'pid' =\u003e 7, 'name' =\u003e '龙都南路'), array('id' =\u003e 10, 'pid' =\u003e 8, 'name' =\u003e 'A店铺'), array('id' =\u003e 11, 'pid' =\u003e 9, 'name' =\u003e 'B店铺'), array('id' =\u003e 12, 'pid' =\u003e 8, 'name' =\u003e 'C店铺'), array('id' =\u003e 13, 'pid' =\u003e 1, 'name' =\u003e '泉州市'), array('id' =\u003e 14, 'pid' =\u003e 13, 'name' =\u003e '南安县'), array('id' =\u003e 15, 'pid' =\u003e 13, 'name' =\u003e '惠安县'), array('id' =\u003e 16, 'pid' =\u003e 14, 'name' =\u003e 'A镇'), array('id' =\u003e 17, 'pid' =\u003e 14, 'name' =\u003e 'B镇'), array('id' =\u003e 18, 'pid' =\u003e 16, 'name' =\u003e 'A村'), array('id' =\u003e 19, 'pid' =\u003e 16, 'name' =\u003e 'B村'), ); // 根据初始数据，生成一个以 id 为 key/下标 的数组，方便根据 pid 判断是否存在父级元素。 $items = array_column($items,null,'id'); //使用 php 的 \u0026 引用特性，遍历一次循环即可生成无限级分类树。（其他高级语言中也有类似的特性，诸如 C++ 的指针和 JAVA 的引用） $tree = []; foreach ($items as $item) { $id = $item['id']; $pid = $item['pid']; if (isset($items[$pid])) $items[$pid]['children'][] = \u0026$items[$id]; else $tree[] = \u0026$items[$id]; } $this-\u003esuccess('ok',$tree); } 输出 { \"code\": 1, \"msg\": \"ok\", \"data\": [ { \"id\": 1, \"pid\": 0, \"name\": \"福建省\", \"children\": [ { \"id\": 3, \"pid\": 1, \"name\": \"福州市\" }, { \"id\": 13, \"pid\": 1, \"name\": \"泉州市\", \"children\": [ { \"id\": 14, \"pid\": 13, \"name\": \"南安县\", \"children\": [ { \"id\": 16, \"pid\": 14, \"name\": \"A镇\", \"children\": [ { \"id\": 18, \"pid\": 16, \"name\": \"A村\" }, { \"id\": 19, \"pid\": 16, \"name\": \"B村\" } ] }, { \"id\": 17, \"pid\": 14, \"name\": \"B镇\" } ] }, { \"id\": 15, \"pid\": 13, \"name\": \"惠安县\" } ] } ] }, { \"id\": 2, \"pid\": 0, \"name\": \"四川省\", \"children\": [ { \"id\": 4, \"pid\": 2, \"name\": \"成都市\", \"children\": [ { \"id\": 6, \"pid\": 4, \"name\": \"成华区\", \"children\": [ { \"id\": 8, \"pid\": 6, \"name\": \"崔家店路\", \"children\": [ { \"id\": 10, \"pid\": 8, \"name\": \"A店铺\" }, { \"id\": 12, \"pid\": 8, \"name\": \"C店铺\" } ] } ] }, { \"id\": 7, \"pid\": 4, \"name\": \"龙泉驿区\", \"children\": [ { \"id\": 9, \"pid\": 7, \"name\": \"龙都南路\", \"children\": [ { \"id\": 11, \"pid\": 9, \"name\": \"B店铺\" } ] } ] } ] }, { \"id\": 5, \"pid\": 2, \"name\": \"乐山市\" } ] } ] ","date":"2020-12-16","objectID":"/2020/12/16/php-%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E6%A0%91/:0:0","series":null,"tags":[],"title":"PHP基于引用特性实现的无限级分类树","uri":"/2020/12/16/php-%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%97%A0%E9%99%90%E7%BA%A7%E5%88%86%E7%B1%BB%E6%A0%91/"},{"categories":["Linux"],"content":"Systemd 服务是一种以 .service 结尾的单元（unit）配置文件，用于控制由 Systemd 控制或监视的进程。简单说，用于后台以守护精灵（daemon）的形式运行程序。Systemd 广泛应用于新版本的 RHEL、SUSE Linux Enterprise、CentOS、Fedora 和 openSUSE 中，用于替代旧有的服务管理器 service。 一、如何创建一个服务？ 这里假设你已经自行编译安装好了 nginx，下面我们来创建一个 nginx.service 文件 vi /etc/systemd/system/nginx.service 内容如下： [Unit] Description=Nginx - high performance web server After=network.target [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/usr/local/nginx/sbin/nginx -s stop [Install] WantedBy=multi-user.target 重新加载服务配置文件，使创建的 nginx 服务生效： systemctl daemon-reload 这样我们就可以用 Systemd 的方式来管理 nginx 了，命令如下： #启动nginx systemctl start nginx #重载nginx systemctl reload nginx #停止nginx systemctl stop nginx #重启nginx systemctl restart nginx #如果需要开机启动 systemctl enable nginx #如果需要取消开机启动 systemctl disable nginx 二、关于 Systemd 服务 Systemd 服务的内容主要分为三个部分，控制单元（unit）的定义、服务（service）的定义、以及安装（install）的定义。 ","date":"2020-12-01","objectID":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/:0:0","series":null,"tags":[],"title":"如何编写一个Linux Systemd Service？","uri":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/"},{"categories":["Linux"],"content":"2.1、控制单元 unit 从上面的例子中我们看到 Unit 内容如下： [Unit] Description=Nginx - high performance web server After=network.target Description：代表整个单元的描述，可根据需要任意填写。 Before/After：指定启动顺序。 network.target 代表有网路，network-online.target 代表一个连通着的网络。 ","date":"2020-12-01","objectID":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/:1:0","series":null,"tags":[],"title":"如何编写一个Linux Systemd Service？","uri":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/"},{"categories":["Linux"],"content":"2.2、服务本体 service [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/usr/local/nginx/sbin/nginx -s stop Type: 服务的类型，各种类型的区别如下所示 simple：默认，这是最简单的服务类型。意思就是说启动的程序就是主体程序，这个程序要是退出那么一切皆休。 forking：标准 Unix Daemon 使用的启动方式。启动程序后会调用 fork () 函数，把必要的通信频道都设置好之后父进程退出，留下守护精灵的子进程。 oneshot：适用于那些被一次性执行的任务或者命令，它运行完成后便了无痕迹。因为这类服务运行完就没有任何痕迹，我们经常会需要使用 RemainAfterExit=yes。意思是说，即使没有进程存在，Systemd 也认为该服务启动成功了。同时只有这种类型支持多条命令，命令之间用；分割，如需换行可以用 \\。 dbus：这个程序启动时需要获取一块 DBus 空间，所以需要和 BusName= 一起用。只有它成功获得了 DBus 空间，依赖它的程序才会被启动。 ExecStart：在输入的命令是 start 时候执行的命令，这里的命令启动的程序必须使用绝对路径，比如你必须用 /sbin/arp 而不能简单的以环境变量直接使用 arp。 ExecStop：在输入的命令是 stop 时候执行的命令，要求同上。 ExecReload：这个不是必需，如果不写则你的 service 就不支持 restart 命令。ExecStart 和 ExecStop 是必须要有的。 ","date":"2020-12-01","objectID":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/:2:0","series":null,"tags":[],"title":"如何编写一个Linux Systemd Service？","uri":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/"},{"categories":["Linux"],"content":"2.3、安装部分 install [Install] WantedBy=multi-user.target WantedBy：运行级别 / 设置服务被谁装载，一般设置为 multi-user.target（从 Centos7 以后 bai 采用 target 概念来定义运行级别，multi-user.target 是第三级别） ","date":"2020-12-01","objectID":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/:3:0","series":null,"tags":[],"title":"如何编写一个Linux Systemd Service？","uri":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/"},{"categories":["Linux"],"content":"2.4、存放的位置 Systemd Service 位于 /etc/systemd/system（供系统管理员和用户使用），/usr/lib/systemd/system（供发行版打包者使用），我们一般使用前者即可。 3、总结 Systemd Service 是一种替代 /etc/init.d/ 下脚本的更好方式，它可以灵活的控制你什么时候要启动服务，一般情况下也不会造成系统无法启动进入紧急模式。所以如果想设置一些开机启动的东西，可以试着写 Systemd Service。当然了，前提是你使用的 Linux 发行版是支持它的才行。 REF https://www.xiaoz.me/archives/14458 https://segmentfault.com/a/1190000014740871 https://zh.opensuse.org/openSUSE:How_to_write_a_systemd_service ","date":"2020-12-01","objectID":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/:4:0","series":null,"tags":[],"title":"如何编写一个Linux Systemd Service？","uri":"/2020/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-systemd-service/"},{"categories":["Linux"],"content":"连接国外或内网 centos7 主机时发现会因为 DNS 的问题造成 SSH 连接速度慢。 SSH 登录太慢可能是 DNS 解析的问题，默认配置下 sshd 初次接受 ssh 客户端连接的时候会自动反向解析客户端 IP 以得到 ssh 客户端的域名或主机名。如果这个时候 DNS 的反向解析不正确，sshd 就会等到 DNS 解析超时后才提供 ssh 连接，这样就造成连接时间过长、ssh 客户端等待的情况，一般为 10-30 秒左右。有个简单的解决办法就是在 sshd 的配置文件（sshd_config）里取消 sshd 的反向 DNS 解析。 编辑 ssh 配置文件 vi /etc/ssh/sshd_config 找到 UseDNS 设置为 no 重启 ssh 服务即可 systemctl restart sshd ","date":"2020-11-28","objectID":"/2020/11/28/centos-ssh-%E7%99%BB%E5%BD%95%E5%A4%AA%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":[],"title":"CentOS SSH 登录太慢的解决方法","uri":"/2020/11/28/centos-ssh-%E7%99%BB%E5%BD%95%E5%A4%AA%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"读取本地文件内容，对文本内容进行中文分词，统计词频后，生成词云图。 一、生成矩形颜色随机的词云图 读取本地文件内容，对文本内容进行中文分词，统计词频后，生成矩形随机颜色的词云图。 import logging import collections import re import math import jieba from wordcloud import WordCloud jieba.setLogLevel(logging.INFO) # 创建停用词列表 def stopwordslist(): # 按行读入 stopwords = [line.strip() for line in open('chinsesstop.txt', encoding='UTF-8').readlines()] # 分割为单个字符（列表解析） stopwords = [k for s in stopwords for k in s] return stopwords # # 指定字符串方式 # text = \"collections在python官方文档中的解释是High-performance container datatypes，直接的中文翻译解释高性能容量数据类型。它总共包含五种数据类型\" # 文件读取方式 f = open(\"./article.txt\", \"r\", encoding=\"utf-8\") text = f.read() f.close() # 生成词云的词频限制，选取前30% TopWordFrequencyPercentage = 30 TopWordFrequencyPercentage /= 100 # 词云图片生成路径（当前目录下的 wordcloud_rectangle.png 文件） PicSavePath = \"./wordcloud_rectangle.png\" # jieba分词 seg = jieba.cut(text) seg = \" \".join(seg) seg = seg.strip() # 去除标点符号 seg = re.sub(r\"[0-9\\s+\\.\\!\\/_,$%^*()?;；:-【】+\\\"\\']+|[+——！，;:：。？、~@#￥%……\u0026*（）]+\", \" \", seg) # 只取中文 # seg = re.sub(r'[^\\u4e00-\\u9fa5]', ' ', seg) # 转换为list seg = seg.split(\" \") # 过滤空字符和None seg = list(filter(None, seg)) # print(seg) # 创建一个停用词列表 stopwords = stopwordslist() # print(stopwords) # 过滤停用词（列表解析） seg = [v for v in seg if v not in stopwords] # print(seg) # 统计词频 word_counts = collections.Counter(seg) # print(word_counts) # print(math.ceil(len(word_counts) * 0.3)) # # 获取词频降序排列的前30% # word_counts_top_50_percent = word_counts.most_common(math.ceil(len(word_counts) * 0.3)) # print(word_counts_top_50_percent) # 生成词云 wc = WordCloud( # 限制词数（根据词频限制，计算个数，向上取整） max_words=math.ceil(len(word_counts) * TopWordFrequencyPercentage), # 设置背景宽 width=500, # 设置背景高 height=350, # 最大字体 max_font_size=50, # 最小字体 min_font_size=10, # 设置字体文件路径，不指定就会出现乱码。 font_path='./MSYH.TTC', # 设置背景色 background_color='white', ) # 根据词频产生词云 wc.generate_from_frequencies(word_counts) # 生成词云图片文件 wc.to_file(PicSavePath) 效果图： 二、根据图片生成规定形状的颜色相近的词云图 读取本地文件内容，对文本内容进行中文分词，统计词频后，根据背景图片生成规定形状和颜色的词云图。 import logging import collections import re import math from random import randint import jieba from wordcloud import WordCloud from wordcloud import ImageColorGenerator from PIL import Image import numpy as np jieba.setLogLevel(logging.INFO) # 创建停用词列表 def stopwordslist(): # 按行读入 stopwords = [line.strip() for line in open('chinsesstop.txt', encoding='UTF-8').readlines()] # 分割为单个字符（列表解析） stopwords = [k for s in stopwords for k in s] return stopwords # 自定义颜色函数（在绘制词云图时发现有的字颜色为黄色导致看不清因此需要修改整个词云图的色调为冷色调 蓝绿色） def random_color_func(word=None, font_size=None, position=None, orientation=None, font_path=None, random_state=None): # what is HSL? https://baike.baidu.com/item/HSL/1443144?fr=aladdin H = randint(120, 250) S = int(100.0 * 255.0 / 255.0) L = int(100.0 * float(randint(60, 120)) / 255.0) return \"hsl({}, {}%, {}%)\".format(H, S, L) # # 指定字符串方式 # text = \"collections在python官方文档中的解释是High-performance container datatypes，直接的中文翻译解释高性能容量数据类型。它总共包含五种数据类型\" # 文件读取方式 f = open(\"./article.txt\", \"r\", encoding=\"utf-8\") text = f.read() f.close() # 生成词云的词频限制，选取前30% TopWordFrequencyPercentage = 30 TopWordFrequencyPercentage /= 100 # 词云图片生成路径（当前目录下的 wordcloud_arbitrary_shape.png 文件） PicSavePath = \"./wordcloud_arbitrary_shape.png\" # jieba分词 seg = jieba.cut(text) seg = \" \".join(seg) seg = seg.strip() # 去除标点符号 seg = re.sub(r\"[0-9\\s+\\.\\!\\/_,$%^*()?;；:-【】+\\\"\\']+|[+——！，;:：。？、~@#￥%……\u0026*（）]+\", \" \", seg) # 只取中文 # seg = re.sub(r'[^\\u4e00-\\u9fa5]', ' ', seg) # 转换为list seg = seg.split(\" \") # 过滤空字符和None seg = list(filter(None, seg)) # print(seg) # 创建一个停用词列表 stopwords = stopwordslist() # print(stopwords) # 过滤停用词（列表解析） seg = [v for v in seg if v not in stopwords] # print(seg) # 统计词频 word_counts = collections.Counter(seg) # print(word_counts) # print(math.ceil(len(word_counts) * 0.3)) # # 获取词频降序排列的前30% # word_counts_top_50_percent = word_counts.most_common(math.ceil(len(word_counts) * 0.3)) # print(word_counts_top_50_percent) # 词云形状 mask = np.array(Image.open(\"./background1.png\")) # 根据图片颜色设置词云颜色(如果背景图片是纯色背景会报 NotImplementedError: Gray-scale images TODO 错","date":"2020-11-18","objectID":"/2020/11/18/python%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%A0%B9%E6%8D%AE%E8%AF%8D%E9%A2%91%E5%92%8C%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/:0:0","series":null,"tags":[],"title":"Python 中文分词，根据词频和背景图片生成词云","uri":"/2020/11/18/python%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%A0%B9%E6%8D%AE%E8%AF%8D%E9%A2%91%E5%92%8C%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/"},{"categories":["Python"],"content":"有时 pip 不指定源安装会比较慢，甚至会安装失败。 #阿里源 pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/ #豆瓣 pip install -r requirements.txt -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com #清华大学 pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ ","date":"2020-11-17","objectID":"/2020/11/17/python-pip%E6%8C%87%E5%AE%9A%E6%BA%90%E5%AE%89%E8%A3%85/:0:0","series":null,"tags":[],"title":"Python pip 指定源安装","uri":"/2020/11/17/python-pip%E6%8C%87%E5%AE%9A%E6%BA%90%E5%AE%89%E8%A3%85/"},{"categories":["Python"],"content":"在查看别人的 Python 项目时，经常会看到一个 requirements.txt 文件，里面记录了当前程序的所有依赖包及其精确版本号，与 npm 的 package.json 很像。其作用是用来在另一台 PC 上重新构建项目所需要的运行环境依赖。 # 导出依赖 pip freeze \u003e requirements.txt # 安装依赖 pip install -r requirements.txt ","date":"2020-11-17","objectID":"/2020/11/17/python-%E5%AF%BC%E5%87%BA-or-%E5%AE%89%E8%A3%85-requirements.txt-%E4%BE%9D%E8%B5%96/:0:0","series":null,"tags":[],"title":"Python 导出 or 安装 requirements.txt 依赖","uri":"/2020/11/17/python-%E5%AF%BC%E5%87%BA-or-%E5%AE%89%E8%A3%85-requirements.txt-%E4%BE%9D%E8%B5%96/"},{"categories":["Python"],"content":"安装完 anaconda 后，打开 Anaconda Powershell Prompt (anaconda3) 执行命令。 一、Anaconda # 查看 conda 版本号 conda --version # 查看系统当前已有的 Python 环境 conda info --envs # 添加一个名为 python27，Python 版本为 2.7 的环境 conda create --name python27 python=2.7 # 查看当前环境的 Python 版本 python --version # 切换 Python 环境到刚才新添加的 Python2.7 conda activate python27 # 切回原来的 Python 环境 conda deactivate python27 # 或 conda activate base # 删除 python27 这个环境 conda remove --name python27 --all # 添加清华源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes # 查看镜像列表 conda config --show channels # 删除某个镜像 conda config --remove channels #如：https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ # 包管理 conda install \u003c包名\u003e 安装指定包 conda remove \u003c包名\u003e 移除指定包 conda update \u003c包名\u003e 更新指定包 二、PyCharm ","date":"2020-11-13","objectID":"/2020/11/13/pycharm-%E4%BD%BF%E7%94%A8-anaconda-%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%AC-python-%E7%8E%AF%E5%A2%83/:0:0","series":null,"tags":[],"title":"PyCharm 使用 Anaconda 管理多版本 Python 环境","uri":"/2020/11/13/pycharm-%E4%BD%BF%E7%94%A8-anaconda-%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%AC-python-%E7%8E%AF%E5%A2%83/"},{"categories":["闲聊"],"content":"关于内容和工具 大概在半年前，尝试并且使用了一些笔记软件，于是逐渐陷入寻找的沼泽里，一发不可收拾，开始体验各种笔记软件，这似乎是陷入了一个不应该存在的怪圈：找笔记APP，体验，找下一个笔记APP。而我们本心不该是这样的，本来是想找个称手的兵器打仗，最后却变成了武器商店的店长。 近期逐渐意识到了，应该逐渐回归初心，想到什么内容，就找合适的地方马上开始写，内容远比载体重要的多。 不再去把大量的时间花在寻找好工具上了，专注于内容产出，提升自己，更加重要。 ","date":"2019-05-18","objectID":"/2019/05/18/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":[],"title":"关于博客","uri":"/2019/05/18/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}]